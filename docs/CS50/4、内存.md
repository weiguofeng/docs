# 4、内存



#### 1、16进制

​			16进制 -- 例如我们的图像显示使用的像素RGB颜色值的表示就是使用的16进制

​		16进制最大的值是F=15，如果是FF = 16*15 + 15 = 255

#### 为什么要使用这种方式呢，因为我们之前使用的是2进制现在为什么又要使用16进制？

​		事实证明，16进制只是为了方便而已，为什么，那么如果字母表中有16个数字，从0-F，你需要多少位，多少个0和1来表示16个不同的值？

​		如果是2进制 就需要4位来表达 2的4次方，如果你有一个数字代表4个位，这对于计算机科学家和程序员来说在实践中很方便，虽然使用2进制的1111可以代表16但这不是一个完整的字节，一个字节是8位，没有人以4为单位进行计数，它总是以8、16、32 、64、等8的倍数进行计数，但事实证明因为16进制使用4个bit，所以如果我们使用2个那么就是8个bit，就是一个字节，是常用的计量单位。

​		这就是为什么Photoshop也使用这种约定，颜色程序也是如此，Web开发也是如此一般都是以2个16进制的数字来表示单个字节。

​	那么关于16进制还有什么问题？



#### 2、内存

​			我们在讨论计算机内存的时候，我们将内存中的每个方框单独的位置代表一个字节，所以我们可以计算计算机内部的字节数，正如我们今天在代码中看到的那样，计算机通常使用数字来表示其内存中所有的字节，并且按照惯例，他们通常使用16进制表示法。

![1716429289592](../.vuepress/public/images/1716429289592.png)



​		技术上讲，如果我们像大多数程序员那样开始对他们进行编号并从零开始计数，那么就是这样的效果

![1716429635253](../.vuepress/public/images/1716429635253.png)



​	我们可能在现实生活中看到例如0x0这样的表达，其实只是在16进制前面加上了0x，这个只是一个约定0x后面的值代表使用的是16进制

​	![1716429808437](../.vuepress/public/images/1716429808437.png)





我们看一下代码中的变量其实在内存中存放也是有具体位置地址的

​		如果我们真的做数学运算的话，这是一个很大的数值，但是我们不需要关心，我们只是关心它存放于某个地方。代码中使用到的p其实就是使用到了C语言中的指针pointers，指针实际上只是一个地址，某个变量的地址，您甚至可以将其存储在另一个称为指针的变量中。

![1716430155150](../.vuepress/public/images/1716430155150.png)





​		如果指针是地址，我们可以开始修改这个想法，比如我们创建一个变量，该变量的目的不是存储像50数字这样的无聊数字，而是存储某个值的地址

![1716430763796](../.vuepress/public/images/1716430763796.png)



在图形化中我们表达一下，新建的p变量 使用的存储指针那么默认是使用8个字节

![1716431079247](../.vuepress/public/images/1716431079247.png)



​		这对我们来说有什么帮助呢？如果我们更抽象的思考一下这个问题，谁会关心计算机内存中发生了什么？当人们普遍地谈论指针和地址时，人们实际上常常将他们抽象出来，因此在讨论这个问题时，不要在屏幕或白板上写字0x123实际地址是什么，没人在乎实际地址是什么，它的价值就是引导我找到我们关心的实际存储的内容值







#### 	3、字符串的实际含义

​		变量s存放的是一个指针地址，而指针的地址指向的是第一个字符最后已 \0也就是nul结束，这样就完整的读取到内存中的字符串变量了

![1716431848746](../.vuepress/public/images/1716431848746.png)





![1716432275350](../.vuepress/public/images/1716432275350.png)







#### 4、字符串比较

​	![1716446724021](../.vuepress/public/images/1716446724021.png)



​	输入相同的内容，但是比较总是显示different

![1716446788710](../.vuepress/public/images/1716446788710.png)



​	因为不同的原因是他们的内存地址不一致，为什么相同的字符串不使用同一个地址呢，因为面临后续可能修改的问题，所以每个字符串都单独分配一个地址

![1716446985763](../.vuepress/public/images/1716446985763.png)



​	所以我们在使用compared比较值的时候，那么就相等了

![1716447225063](../.vuepress/public/images/1716447225063.png)





​	我们在输入相同字符串将内存地址打印后可以看出，内存的地址是不同的，虽然离着很近

​	b0和f0

![1716447480181](../.vuepress/public/images/1716447480181.png)



#### 5、字符串copy

​		赋值字符串，那么将使用相同的内存地址





​	如果使用函数malloc的话会重新分配内存

![1716448272322](../.vuepress/public/images/1716448272322.png)



​		malloc如果一直分配内存不进行释放，那么就会使系统变的庞大 内存也会慢慢堆积不够使用，所以我们要进行内存的释放free函数 -- 在我们使用完成后进行对内存的释放

![1716448640648](../.vuepress/public/images/1716448640648.png)



#### 6、内存检查

​		valgrind 是内存检查工具

![1716448814727](../.vuepress/public/images/1716448814727.png)







​	假设我们自定义内存的使用为 3 * 4 = 12个字节

![1716449300394](../.vuepress/public/images/1716449300394.png)





​		使用valarind检查代码的时候就会提示我们 将会丢失12个字节，因为我们使用malloc而并没有进行释放free

![1716449275289](../.vuepress/public/images/1716449275289.png)



​		代码进行释放

![1716449539942](../.vuepress/public/images/1716449539942.png)

​	

​		再次运行，发现不会有内存泄漏的风险 -- 内存泄漏其实就是你之后将找不到这个内存地址，你一直无法将它释放，这块内存地址将一直被使用着

![1716449602316](../.vuepress/public/images/1716449602316.png)



![1716449851057](../.vuepress/public/images/1716449851057.png)





#### 7、垃圾处理Garbage

​	如果我们定义一个1024字节的数组，但从未真正将值放入其中，也没有任何对它的引用

那么这里将有1024个垃圾值，某些情况下会默认初始化值为0，但我们只要不是自己在操作这些值的话那么这些值是不能被信任的

![1716450927270](../.vuepress/public/images/1716450927270.png)



![1716450720699](../.vuepress/public/images/1716450720699.png)





#### 8、swapping 交换值

​		我们想把x 和y 进行值的交换

​		但是运行代码后发现值并没有发生真正的交换

![1716451370590](../.vuepress/public/images/1716451370590.png)



![1716451544206](../.vuepress/public/images/1716451544206.png)



​		为什么会是这样的效果呢？





​			内存分布效果图

![1716451782851](../.vuepress/public/images/1716451782851.png)



我们先了解一下栈 stack

​		当我们执行类似函数操作的时候，我们关注堆栈，例如以下代码

![1716451922113](../.vuepress/public/images/1716451922113.png)

​	它不允许我们永久的改变这些值，为什么？



​	在堆栈中的这个main方法，在计算机内存中第一个函数存在的位置，所以主要的是，如果你有任何变量，一旦你加载该程序，他们就会进入计算机内存的底部。

![1716452006762](../.vuepress/public/images/1716452006762.png)



​	所以当main调用swap时，swap位于栈的上方

![1716452260044](../.vuepress/public/images/1716452260044.png)

​	而一旦调用完成该内存就会基本消失，或者计算机会忘记它，即使这些位依然存在，而main会一直保留，直到main完成并退出

![1716452424002](../.vuepress/public/images/1716452424002.png)

​	现在我们考虑一下这些堆栈内部发生了什么

​	在底部的main中，他有俩个变量 x和 y 分别是1和2

![1716452598541](../.vuepress/public/images/1716452598541.png)



​		内存分布是这样的 swap

![1716452700922](../.vuepress/public/images/1716452700922.png)



​		在swap函数调用完之后是这样的

![1716452762720](../.vuepress/public/images/1716452762720.png)

​		但是并没有在内存中交换x和y的值，我们只是对其副本a和b进行了值的操作，这个交换函数虽然在逻辑上是正确的，但永远不会像编写的逻辑正确的解决这个问题，因为我们一直是在 **按值传递**



​	所以我们可以通过引用传递，通过指针传递也就是内存地址传递

![1716453035245](../.vuepress/public/images/1716453035245.png)

![1716453116447](../.vuepress/public/images/1716453116447.png)



![1716453295656](../.vuepress/public/images/1716453295656.png)







#### 9、IO

​		文件io，例如可以访问图像文件，文本文件或与文件相关的

![1716473334321](../.vuepress/public/images/1716473334321.png)





![1716473660446](../.vuepress/public/images/1716473660446.png)





![1716473673335](../.vuepress/public/images/1716473673335.png)





​		现在我们再写一个copy的程序

![1716474210540](../.vuepress/public/images/1716474210540.png)





​	没有问题copy文件成功了

![1716474237027](../.vuepress/public/images/1716474237027.png)

















https://www.youtube.com/watch?v=F9-yqoS7b8w