(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{523:function(s,n,a){"use strict";a.r(n);var t=a(3),e=Object(t.a)({},(function(){var s=this,n=s.$createElement,a=s._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:""}},[a("a",{staticClass:"header-anchor",attrs:{href:"#"}},[s._v("#")]),s._v(" "),a("img",{attrs:{src:"https://i.loli.net/2020/11/24/6rWPzvf29YjRDJw.jpg",alt:""}})]),s._v(" "),a("h2",{attrs:{id:"引导语"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引导语"}},[s._v("#")]),s._v(" 引导语")]),s._v(" "),a("p",[s._v("String 和 Long 大家都很熟悉，本小节主要结合实际的工作场景，来一起看下 String 和 Long 的底层源码实现，看看平时我们使用时，有无需要注意的点，总结一下这些 API 都适用于哪些场景。")]),s._v(" "),a("h2",{attrs:{id:"_1-string"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-string"}},[s._v("#")]),s._v(" 1 String")]),s._v(" "),a("h3",{attrs:{id:"_1-1-不变性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-不变性"}},[s._v("#")]),s._v(" 1.1 不变性")]),s._v(" "),a("p",[s._v("我们常常听人说，HashMap 的 key 建议使用不可变类，比如说 String 这种不可变类。这里说的不可变指的是类值一旦被初始化，就不能再被改变了，如果被修改，将会是新的类，我们写个 demo 来演示一下。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('String s ="hello";\ns ="world";\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("从代码上来看，s 的值好像被修改了，但从 debug 的日志来看，其实是 s 的内存地址已经被修改了，也就说 s =“world” 这个看似简单的赋值，其实已经把 s 的引用指向了新的 String，debug 的截图显示内存地址已经被修改，两张截图如下：\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/jpeg/1534454/1591251281750-629c6b27-e701-454a-a0c9-a1d8a99dcc8d.jpeg#align=left&display=inline&height=96&margin=%5Bobject%20Object%5D&originHeight=96&originWidth=884&size=0&status=done&style=none&width=884",alt:""}}),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/jpeg/1534454/1591251281738-b7dd1324-818b-4698-9307-d418b0ea568f.jpeg#align=left&display=inline&height=90&margin=%5Bobject%20Object%5D&originHeight=90&originWidth=1054&size=0&status=done&style=none&width=1054",alt:""}}),s._v("我们从源码上查看一下原因：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("public final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n    /** The value is used for character storage. */\n    private final char value[];\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("我们可以看出来两点：")]),s._v(" "),a("ol",[a("li",[s._v("String 被 final 修饰，说明 String 类绝不可能被继承了，也就是说任何对 String 的操作方法，都不会被继承覆写；")]),s._v(" "),a("li",[s._v("String 中保存数据的是一个 char 的数组 value。我们发现 value 也是被 final 修饰的，也就是说 value 一旦被赋值，内存地址是绝对无法修改的，而且 value 的权限是 private 的，外部绝对访问不到，String 也没有开放出可以对 value 进行赋值的方法，所以说 value 一旦产生，内存地址就根本无法被修改。")])]),s._v(" "),a("p",[s._v("以上两点就是 String 不变性的原因，充分利用了 final 关键字的特性，如果你自定义类时，希望也是不可变的，也可以模仿 String 的这两点操作。\n因为 String 具有不变性，所以 String 的大多数操作方法，都会返回新的 String，如下面这种写法是不对的：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('String str ="hello world !!";\n// 这种写法是替换不掉的，必须接受 replace 方法返回的参数才行，这样才行：str = str.replace("l","dd");\nstr.replace("l","dd");\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("h3",{attrs:{id:"_1-2-字符串乱码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-字符串乱码"}},[s._v("#")]),s._v(" 1.2 字符串乱码")]),s._v(" "),a("p",[s._v("在生活中，我们经常碰到这样的场景，进行二进制转化操作时，本地测试的都没有问题，到其它环境机器上时，有时会出现字符串乱码的情况，这个主要是因为在二进制转化操作时，并没有强制规定文件编码，而不同的环境默认的文件编码不一致导致的。\n我们也写了一个 demo 来模仿一下字符串乱码：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('String str  ="nihao 你好 喬亂";\n// 字符串转化成 byte 数组\nbyte[] bytes = str.getBytes("ISO-8859-1");\n// byte 数组转化成字符串\nString s2 = new String(bytes);\nlog.info(s2);\n// 结果打印为：\nnihao ?? ??\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("p",[s._v("打印的结果为？？，这就是常见的乱码表现形式。这时候有同学说，是不是我把代码修改成 "),a("code",[s._v('String s2 = new String(bytes,"ISO-8859-1");')]),s._v(" 就可以了？这是不行的。主要是因为 ISO-8859-1 这种编码对中文的支持有限，导致中文会显示乱码。唯一的解决办法，就是在所有需要用到编码的地方，都统一使用 UTF-8，对于 String 来说，getBytes 和 new String 两个方法都会使用到编码，我们把这两处的编码替换成 UTF-8 后，打印出的结果就正常了。")]),s._v(" "),a("h3",{attrs:{id:"_1-3-首字母大小写"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-首字母大小写"}},[s._v("#")]),s._v(" 1.3 首字母大小写")]),s._v(" "),a("p",[s._v("如果我们的项目被 Spring 托管的话，有时候我们会通过 "),a("code",[s._v("applicationContext.getBean(className);")]),s._v(" 这种方式得到 SpringBean，这时 className 必须是要满足首字母小写的，除了该场景，在反射场景下面，我们也经常要使类属性的首字母小写，这时候我们一般都会这么做：\n"),a("code",[s._v("name.substring(0, 1).toLowerCase() + name.substring(1);")]),s._v("，使用 substring 方法，该方法主要是为了截取字符串连续的一部分，substring 有两个方法：")]),s._v(" "),a("ol",[a("li",[a("code",[s._v("public String substring(int beginIndex, int endIndex)")]),s._v(" beginIndex：开始位置，endIndex：结束位置；")]),s._v(" "),a("li",[a("code",[s._v("public String substring(int beginIndex)")]),s._v("beginIndex：开始位置，结束位置为文本末尾。")])]),s._v(" "),a("p",[s._v("substring 方法的底层使用的是字符数组范围截取的方法 ："),a("code",[s._v("Arrays.copyOfRange(字符数组, 开始位置, 结束位置);")]),s._v(" 从字符数组中进行一段范围的拷贝。\n相反的，如果要修改成首字母大写，只需要修改成 "),a("code",[s._v("name.substring(0, 1).toUpperCase() + name.substring(1)")]),s._v(" 即可。")]),s._v(" "),a("h3",{attrs:{id:"_1-4-相等判断"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-相等判断"}},[s._v("#")]),s._v(" 1.4 相等判断")]),s._v(" "),a("p",[s._v("我们判断相等有两种办法，equals 和 equalsIgnoreCase。后者判断相等时，会忽略大小写，近期看见一些面试题在问：如果让你写判断两个 String 相等的逻辑，应该如何写，我们来一起看下 equals 的源码，整理一下思路：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("public boolean equals(Object anObject) {\n    // 判断内存地址是否相同\n    if (this == anObject) {\n        return true;\n    }\n    // 待比较的对象是否是 String，如果不是 String，直接返回不相等\n    if (anObject instanceof String) {\n        String anotherString = (String)anObject;\n        int n = value.length;\n        // 两个字符串的长度是否相等，不等则直接返回不相等\n        if (n == anotherString.value.length) {\n            char v1[] = value;\n            char v2[] = anotherString.value;\n            int i = 0;\n            // 依次比较每个字符是否相等，若有一个不等，直接返回不相等\n            while (n-- != 0) {\n                if (v1[i] != v2[i])\n                    return false;\n                i++;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br")])]),a("p",[s._v("从 equals 的源码可以看出，逻辑非常清晰，完全是根据 String 底层的结构来编写出相等的代码。这也提供了一种思路给我们：如果有人问如何判断两者是否相等时，我们可以从两者的底层结构出发，这样可以迅速想到一种贴合实际的思路和方法，就像 String 底层的数据结构是 char 的数组一样，判断相等时，就挨个比较 char 数组中的字符是否相等即可。")]),s._v(" "),a("h3",{attrs:{id:"_1-5-替换、删除"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-替换、删除"}},[s._v("#")]),s._v(" 1.5 替换、删除")]),s._v(" "),a("p",[s._v("替换在工作中也经常使用，有 replace 替换所有字符、replaceAll 批量替换字符串、replaceFirst 替换遇到的第一个字符串三种场景。\n其中在使用 replace 时需要注意，replace 有两个方法，一个入参是 char，一个入参是 String，前者表示替换所有字符，如："),a("code",[s._v("name.replace('a','b')")]),s._v("，后者表示替换所有字符串，如："),a("code",[s._v('name.replace("a","b")')]),s._v("，两者就是单引号和多引号的区别。\n需要注意的是， replace 并不只是替换一个，是替换所有匹配到的字符或字符串哦。\n写了一个 demo 演示一下三种场景：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('public void testReplace(){\n  String str ="hello word !!";\n  log.info("替换之前 :{}",str);\n  str = str.replace(\'l\',\'d\');\n  log.info("替换所有字符 :{}",str);\n  str = str.replaceAll("d","l");\n  log.info("替换全部 :{}",str);\n  str = str.replaceFirst("l","");\n  log.info("替换第一个 l :{}",str);\n}\n//输出的结果是：\n替换之前 :hello word !!\n替换所有字符 :heddo word !!\n替换全部 :hello worl !!\n替换第一个 :helo worl !!\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br")])]),a("p",[s._v("当然我们想要删除某些字符，也可以使用 replace 方法，把想删除的字符替换成 “” 即可。")]),s._v(" "),a("h3",{attrs:{id:"_1-6-拆分和合并"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-拆分和合并"}},[s._v("#")]),s._v(" 1.6 拆分和合并")]),s._v(" "),a("p",[s._v("拆分我们使用 split 方法，该方法有两个入参数。第一个参数是我们拆分的标准字符，第二个参数是一个 int 值，叫 limit，来限制我们需要拆分成几个元素。如果 limit 比实际能拆分的个数小，按照 limit 的个数进行拆分，我们演示一个 demo：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('String s ="boo:and:foo";\n// 我们对 s 进行了各种拆分，演示的代码和结果是：\ns.split(":") 结果:["boo","and","foo"]\ns.split(":",2) 结果:["boo","and:foo"]\ns.split(":",5) 结果:["boo","and","foo"]\ns.split(":",-2) 结果:["boo","and","foo"]\ns.split("o") 结果:["b","",":and:f"]\ns.split("o",2) 结果:["b","o:and:foo"]\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("p",[s._v("从演示的结果来看，limit 对拆分的结果，是具有限制作用的，还有就是拆分结果里面不会出现被拆分的字段。\n那如果字符串里面有一些空值呢，拆分的结果如下：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('String a =",a,,b,";\na.split(",") 结果:["","a","","b"]\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("从拆分结果中，我们可以看到，空值是拆分不掉的，仍然成为结果数组的一员，如果我们想删除空值，只能自己拿到结果后再做操作，但 Guava（Google 开源的技术工具） 提供了一些可靠的工具类，可以帮助我们快速去掉空值，如下：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('String a =",a, ,  b  c ,";\n// Splitter 是 Guava 提供的 API \nList<String> list = Splitter.on(\',\')\n    .trimResults()// 去掉空格\n    .omitEmptyStrings()// 去掉空值\n    .splitToList(a);\nlog.info("Guava 去掉空格的分割方法：{}",JSON.toJSONString(list));\n// 打印出的结果为：\n["a","b  c"]\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("p",[s._v("从打印的结果中，可以看到去掉了空格和空值，这正是我们工作中常常期望的结果，所以推荐使用 Guava 的 API 对字符串进行分割。\n合并我们使用 join 方法，此方法是静态的，我们可以直接使用。方法有两个入参，参数一是合并的分隔符，参数二是合并的数据源，数据源支持数组和 List，在使用的时候，我们发现有两个不太方便的地方：")]),s._v(" "),a("ol",[a("li",[s._v("不支持依次 join 多个字符串，比如我们想依次 join 字符串 s 和 s1，如果你这么写的话 "),a("code",[s._v('String.join(",",s).join(",",s1)')]),s._v(" 最后得到的是 s1 的值，第一次 join 的值被第二次 join 覆盖了；")]),s._v(" "),a("li",[s._v("如果 join 的是一个 List，无法自动过滤掉 null 值。")])]),s._v(" "),a("p",[s._v("而 Guava 正好提供了 API，解决上述问题，我们来演示一下：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('// 依次 join 多个字符串，Joiner 是 Guava 提供的 API\nJoiner joiner = Joiner.on(",").skipNulls();\nString result = joiner.join("hello",null,"china");\nlog.info("依次 join 多个字符串:{}",result);\nList<String> list = Lists.newArrayList(new String[]{"hello","china",null});\nlog.info("自动删除 list 中空值:{}",joiner.join(list));\n// 输出的结果为；\n依次 join 多个字符串:hello,china\n自动删除 list 中空值:hello,china\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("p",[s._v("从结果中，我们可以看到 Guava 不仅仅支持多个字符串的合并，还帮助我们去掉了 List 中的空值，这就是我们在工作中常常需要得到的结果。")]),s._v(" "),a("h2",{attrs:{id:"_2-long"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-long"}},[s._v("#")]),s._v(" 2 Long")]),s._v(" "),a("h3",{attrs:{id:"_2-1-缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-缓存"}},[s._v("#")]),s._v(" 2.1 缓存")]),s._v(" "),a("p",[s._v("Long 最被我们关注的就是 Long 的缓存问题，Long 自己实现了一种缓存机制，缓存了从 -128 到 127 内的所有 Long 值，如果是这个范围内的 Long 值，就不会初始化，而是从缓存中拿，缓存初始化源码如下：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("private static class LongCache {\n    private LongCache(){}\n    // 缓存，范围从 -128 到 127，+1 是因为有个 0\n    static final Long cache[] = new Long[-(-128) + 127 + 1];\n    // 容器初始化时，进行加载\n    static {\n        // 缓存 Long 值，注意这里是 i - 128 ，所以再拿的时候就需要 + 128\n        for(int i = 0; i < cache.length; i++)\n            cache[i] = new Long(i - 128);\n    }\n}\n预览\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br")])]),a("h2",{attrs:{id:"_3-面试题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-面试题"}},[s._v("#")]),s._v(" 3 面试题")]),s._v(" "),a("h3",{attrs:{id:"_3-1-为什么使用-long-时-大家推荐多使用-valueof-方法-少使用-parselong-方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-为什么使用-long-时-大家推荐多使用-valueof-方法-少使用-parselong-方法"}},[s._v("#")]),s._v(" 3.1 为什么使用 Long 时，大家推荐多使用 valueOf 方法，少使用 parseLong 方法")]),s._v(" "),a("p",[s._v("答：因为 Long 本身有缓存机制，缓存了 -128 到 127 范围内的 Long，valueOf 方法会从缓存中去拿值，如果命中缓存，会减少资源的开销，parseLong 方法就没有这个机制。")]),s._v(" "),a("h3",{attrs:{id:"_3-2-如何解决-string-乱码的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-如何解决-string-乱码的问题"}},[s._v("#")]),s._v(" 3.2 如何解决 String 乱码的问题")]),s._v(" "),a("p",[s._v("答：乱码的问题的根源主要是两个：字符集不支持复杂汉字、二进制进行转化时字符集不匹配，所以在 String 乱码时我们可以这么做：")]),s._v(" "),a("ol",[a("li",[s._v("所有可以指定字符集的地方强制指定字符集，比如 new String 和 getBytes 这两个地方；")]),s._v(" "),a("li",[s._v("我们应该使用 UTF-8 这种能完整支持复杂汉字的字符集。")])]),s._v(" "),a("h3",{attrs:{id:"_3-3-为什么大家都说-string-是不可变的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-为什么大家都说-string-是不可变的"}},[s._v("#")]),s._v(" 3.3 为什么大家都说 String 是不可变的")]),s._v(" "),a("p",[s._v("答：主要是因为 String 和保存数据的 char 数组，都被 final 关键字所修饰，所以是不可变的，具体细节描述可以参考上文。")]),s._v(" "),a("h3",{attrs:{id:"_3-4-string-一些常用操作问题-如问如何分割、合并、替换、删除、截取等等问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-string-一些常用操作问题-如问如何分割、合并、替换、删除、截取等等问题"}},[s._v("#")]),s._v(" 3.4 String 一些常用操作问题，如问如何分割、合并、替换、删除、截取等等问题")]),s._v(" "),a("p",[s._v("答：这些都属于问 String 的基本操作题目，考察我们平时对 String 的使用熟练程度，可以参考上文。")]),s._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),a("p",[s._v("String 和 Long 在我们工作中使用频率很高，在面试的过程中，考官也喜欢问一些关于实际操作的问题，来考察我们的使用熟练度，所以本文中列举的一些 demo，大家可以试试手，完整的代码可以去 GitHub 上面去拉取。")])])}),[],!1,null,null,null);n.default=e.exports}}]);