(window.webpackJsonp=window.webpackJsonp||[]).push([[184],{5435:function(t,s,a){t.exports=a.p+"assets/img/image-20220410105308505.3b252bc1.png"},5436:function(t,s,a){t.exports=a.p+"assets/img/image-20220410105612234.e6f193aa.png"},5437:function(t,s,a){t.exports=a.p+"assets/img/image-20220410105640872.fb7708da.png"},5438:function(t,s,a){t.exports=a.p+"assets/img/image-20220410110324487.fc6a6265.png"},5439:function(t,s,a){t.exports=a.p+"assets/img/image-20220410110559177.c40ea0aa.png"},5440:function(t,s,a){t.exports=a.p+"assets/img/image-20220410110651297.2fd85ae3.png"},5441:function(t,s,a){t.exports=a.p+"assets/img/image-20220410110756542.83560a8a.png"},5442:function(t,s,a){t.exports=a.p+"assets/img/image-20220410111210652.0b5582f2.png"},5443:function(t,s,a){t.exports=a.p+"assets/img/image-20220410111629693.49438636.png"},5444:function(t,s,a){t.exports=a.p+"assets/img/image-20220410111815844.734118bf.png"},5445:function(t,s,a){t.exports=a.p+"assets/img/image-20220410111857883.4ed2ced8.png"},5446:function(t,s,a){t.exports=a.p+"assets/img/image-20220410115949129.7452d8e2.png"},5447:function(t,s,a){t.exports=a.p+"assets/img/image-20220410120209105.fe40a70e.png"},5448:function(t,s,a){t.exports=a.p+"assets/img/image-20220410120610660.68a207b5.png"},5449:function(t,s,a){t.exports=a.p+"assets/img/image-20220410121641509.a69d0be7.png"},8749:function(t,s,a){"use strict";a.r(s);var e=a(5),i=Object(e.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"_23-上行和下行"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_23-上行和下行"}},[t._v("#")]),t._v(" 23.上行和下行")]),t._v(" "),e("p",[t._v("​\tUpcasting and Downcasting :向上转型和向下转型")]),t._v(" "),e("p",[t._v("​\t\t向上转型，表示将对象强制转换为超类型或父类型之一")]),t._v(" "),e("p",[t._v("​\t\t向下转型，是将对象强制转换为子类型之一。")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5435),alt:"image-20220410105308505"}})]),t._v(" "),e("p",[t._v("​\t让我们实际操作演示一下：")]),t._v(" "),e("p",[t._v("​\t\t我们在main方法中声明一个UI控件类 属于父类")]),t._v(" "),e("p",[t._v("​\t\t然后写一个show方法，并指定参数为UI控件类，然后我们将这个对象打印到控制台")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5436),alt:"image-20220410105612234"}})]),t._v(" "),e("p",[t._v("我们可以看到控制台返回的内容")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5437),alt:"image-20220410105640872"}})]),t._v(" "),e("p",[t._v("现在如果相反我们将他的子类TextBox对象传递给show方法可以吗？我们发现也是可以传入的代码完全有效，因为这个文本框对象继承了UI控件对象的所有成员，所以文本框对象也是一个控件对象，这就是为什么我们说继承代表且是一种关系。")]),t._v(" "),e("p",[t._v("​\t\t这个对象会被自动转换，对于ui控件对象，这就是我们说的向上转型")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5438),alt:"image-20220410110324487"}})]),t._v(" "),e("p",[t._v("​\t将对象转换为其父对象，我们也可以将参数类型设置为Object对象，再次向上转换，因为每个TextBox也是一个Object对象")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5439),alt:"image-20220410110559177"}})]),t._v(" "),e("p",[t._v("​\t我们切换回父类对象为参数，我们测试打印一下内容")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5440),alt:"image-20220410110651297"}})]),t._v(" "),e("p",[t._v("我们看到没有任何输出内容，为什么？")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5441),alt:"image-20220410110756542"}})]),t._v(" "),e("p",[t._v("​\t因为我们之前在TextBox中重写的toString方法，所以我们改变这个方法的默认实现")]),t._v(" "),e("p",[t._v("​\t那么其实当执行第12行的时候，实际上执行的是TextBox的toString方法，而不是UIControl的toString方法，因为我们传入的是TextBox")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5442),alt:"image-20220410111210652"}})]),t._v(" "),e("p",[t._v("​\t有趣的是，在运行的时候这里传递的是TextBox对象，在编译的时候，对这个方法进行编码，我们无法访问到TextBox中的任何方法，例如我们输入control点内容，你只看到UIControl对象中的内容，现在如果想使用TextBox中的其中一个方法呢？")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5443),alt:"image-20220410111629693"}})]),t._v(" "),e("p",[t._v("​\t如果想使用TextBox中的方法就需要显式强制转换为子类TextBox")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5444),alt:"image-20220410111815844"}})]),t._v(" "),e("p",[t._v("​\t现在我们运行一下程序，看一下结果")]),t._v(" "),e("p",[t._v("输出的结果是 我们设置的text字段的值，因为我们之前重写的toString方法，所以显式Hello World")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5445),alt:"image-20220410111857883"}})]),t._v(" "),e("p",[t._v("​\t因为show方法需要接收一个UIControl对象，在编译的时候，我们可以给出一个实例，对UIControl对象或者是派生的子类，但是我们只能在UIControl的成员中工作，在此基础上我们可以显式的将此UIControl对象强制转换为不同的类型，这就是我们所说的向下转型")]),t._v(" "),e("p",[t._v("​\t现在有一个这个实现中的问题，如果我们传入的是UIControl对象实例，和参数一种没问题，然后强制转换后，设置字段值，然后打印这样的逻辑，然而当我们运行程序的时候，我们的程序将毫无例外的崩溃")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5446),alt:"image-20220410115949129"}})]),t._v(" "),e("p",[t._v("​\t提示类型转换异常了--其实我们想把UIControl转换为TextBox这对Java来说毫无意义，原因如下，当然每个文本对象都是控件对象，但不是每个控件对象都是文本对象，这就是为什么这里会有一个异常")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5447),alt:"image-20220410120209105"}})]),t._v(" "),e("p",[t._v("UIControl不能强制转换TextBox")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5448),alt:"image-20220410120610660"}})]),t._v(" "),e("p",[t._v("​\t那么，我们如何防止这种错误的发生呢？如果要强制向下转换类型，我们需要确保运行时传递到这里的对象，如上面的例子，我们得确保他传入过来的是TextBox对象实例，我们才可以转换为TextBox实例，这样的话我们就安全了")]),t._v(" "),e("p",[t._v("​\t这里我们可以加一个判断一下，如果传递过来的control是 instanceof TextBox对象的话，我们再执行强制转换")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5449),alt:"image-20220410121641509"}})]),t._v(" "),e("p",[t._v("​")])])}),[],!1,null,null,null);s.default=i.exports}}]);