(window.webpackJsonp=window.webpackJsonp||[]).push([[782],{8727:function(t,a,e){"use strict";e.r(a);var r=e(5),n=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"_41-pravite-method"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_41-pravite-method"}},[t._v("#")]),t._v(" 41.Pravite Method")]),t._v(" "),e("p",[t._v("​\t\t在Java9中引入的另一个糟糕的特性是，实现接口中的私有方法，当我们第一次听到这个的时候，心想这是在开玩笑吧，这可能是Java有史以来最糟糕的事情吧。")]),t._v(" "),e("p",[t._v("​\t\t他们的执行细节为什么要在接口中允许他们呢？很不明白，我们很想问问Java开发团队，有人是这样说的，为什么需要这个功能，作为编写静态方法的一部分，首先我们可能会有一些重复的逻辑，所以我们可以重构代码，将冗余的逻辑提取到接口中的私有方法，这就是为什么这个功能已被请求并添加到接口中，非常糟糕，我们之前说过，接口是约定，他们不应该有代码，没有实现，没有静态方法，没有字段，什么都没有只是方法声明。")]),t._v(" "),e("p",[t._v("​\t\t再一次，当Jon告诉我，为什么我们需要在接口中使用这些功能时，我知道他对接口和面向对象一无所知，这就是为什么他讨厌面向对象，这就是为什么他喜欢函数式编程，因为在函数式编程中，他不必担心任何微妙但重要的细节。他不需要隐藏实现细节，也不需要理解在紧密耦合和松散耦合的代码之间其中的差异，以及如何使用接口以实现松散耦合的设计，我只是想澄清一下，我不是说函数式编程没用或面向对象更好，他们都是构建软件的伟大范例，他们有自己的使用特点。我的意思是像Jon这样的人讨厌面向对象，是因为他没有正确的学习编程，他们没有学习基本的知识概念和技巧，最终写的难看而无法维护还复杂的代码。")]),t._v(" "),e("p",[t._v("​\t\t这并不意味着面向对象编程是垃圾，而是因为你不知道如何正确的使用，而并非他是不好的。")])])}),[],!1,null,null,null);a.default=n.exports}}]);