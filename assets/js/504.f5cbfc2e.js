(window.webpackJsonp=window.webpackJsonp||[]).push([[504],{5028:function(t,s,e){t.exports=e.p+"assets/img/1685012839252.2895d169.png"},5029:function(t,s,e){t.exports=e.p+"assets/img/1685012881274.0c4f8153.png"},5030:function(t,s,e){t.exports=e.p+"assets/img/1685012892775.9171c0d4.png"},5031:function(t,s,e){t.exports=e.p+"assets/img/1685012914697.55c5efa6.png"},8683:function(t,s,e){"use strict";e.r(s);var n=e(5),p=Object(n.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"_5、spring接口多实现如何使用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5、spring接口多实现如何使用"}},[t._v("#")]),t._v(" 5、spring接口多实现如何使用")]),t._v(" "),n("p",[t._v("​\t\t\t我们平时定义一些service的接口，那么这个接口可能需要有多种实现，我们会根据不同的场景去做不同的实现，所以就需要到了这个如何使用这个多实现的接口")]),t._v(" "),n("p",[t._v("现在假设一个情景，前端传入不同的用户类型，后端返回该用户的任务。")]),t._v(" "),n("p",[t._v("你可能问我，为什么不直接把（用户类型，用户任务）存入数据库？")]),t._v(" "),n("p",[n("img",{attrs:{src:e(5028),alt:"1685012839252"}})]),t._v(" "),n("p",[n("img",{attrs:{src:e(5029),alt:"1685012881274"}})]),t._v(" "),n("p",[n("img",{attrs:{src:e(5030),alt:"1685012892775"}})]),t._v(" "),n("p",[n("img",{attrs:{src:e(5031),alt:"1685012914697"}})]),t._v(" "),n("p",[t._v('​\t\t其实使用Map<String, 对象> instance；这种方式注入后，spring会自动的将多个实现放入到这个Map中，key就是，我们在实现类上写的@Server("key")')]),t._v(" "),n("p",[t._v("​")]),t._v(" "),n("p",[t._v("​\t\t我们在使用的时候 只需要在这个注入的 map 实例上get具体的实现--传入具体实现的key，然后调用方法就可以完成具体的业务了")]),t._v(" "),n("p",[t._v('​\t\t\tinstanceService.get("Key").method();')]),t._v(" "),n("p",[t._v("https://blog.csdn.net/qq_33591903/article/details/104813512")])])}),[],!1,null,null,null);s.default=p.exports}}]);