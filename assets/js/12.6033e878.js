(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{614:function(t,s,a){t.exports=a.p+"assets/img/1716429289592.32c6cf91.png"},615:function(t,s,a){t.exports=a.p+"assets/img/1716429635253.bf071f2d.png"},616:function(t,s,a){t.exports=a.p+"assets/img/1716429808437.d73b3e72.png"},617:function(t,s,a){t.exports=a.p+"assets/img/1716430155150.d238724d.png"},618:function(t,s,a){t.exports=a.p+"assets/img/1716430763796.71bb588e.png"},619:function(t,s,a){t.exports=a.p+"assets/img/1716431079247.e22200c2.png"},620:function(t,s,a){t.exports=a.p+"assets/img/1716431848746.ef88104b.png"},621:function(t,s,a){t.exports=a.p+"assets/img/1716432275350.d1c0ec4e.png"},622:function(t,s,a){t.exports=a.p+"assets/img/1716446724021.946c6e1f.png"},623:function(t,s,a){t.exports=a.p+"assets/img/1716446788710.7315c1bb.png"},624:function(t,s,a){t.exports=a.p+"assets/img/1716446985763.0c8b7962.png"},625:function(t,s,a){t.exports=a.p+"assets/img/1716447225063.b33c6d24.png"},626:function(t,s,a){t.exports=a.p+"assets/img/1716447480181.d91c80de.png"},627:function(t,s,a){t.exports=a.p+"assets/img/1716448272322.8596a312.png"},628:function(t,s,a){t.exports=a.p+"assets/img/1716448640648.bac5dd4f.png"},629:function(t,s,a){t.exports=a.p+"assets/img/1716448814727.5a20b166.png"},630:function(t,s,a){t.exports=a.p+"assets/img/1716449300394.33fddecf.png"},631:function(t,s,a){t.exports=a.p+"assets/img/1716449275289.7c3097e8.png"},632:function(t,s,a){t.exports=a.p+"assets/img/1716449539942.fe0163d9.png"},633:function(t,s,a){t.exports=a.p+"assets/img/1716449602316.f4a532f3.png"},634:function(t,s,a){t.exports=a.p+"assets/img/1716449851057.6c29c9e1.png"},635:function(t,s,a){t.exports=a.p+"assets/img/1716450927270.7f6ae7f4.png"},636:function(t,s,a){t.exports=a.p+"assets/img/1716450720699.32532079.png"},637:function(t,s,a){t.exports=a.p+"assets/img/1716451370590.2b4e4178.png"},638:function(t,s,a){t.exports=a.p+"assets/img/1716451544206.e423ea43.png"},639:function(t,s,a){t.exports=a.p+"assets/img/1716451782851.e5d20542.png"},640:function(t,s,a){t.exports=a.p+"assets/img/1716451922113.638682b3.png"},641:function(t,s,a){t.exports=a.p+"assets/img/1716452006762.4827a40e.png"},642:function(t,s,a){t.exports=a.p+"assets/img/1716452260044.f9c36a9b.png"},643:function(t,s,a){t.exports=a.p+"assets/img/1716452424002.d3cfff14.png"},644:function(t,s,a){t.exports=a.p+"assets/img/1716452598541.c2b451ce.png"},645:function(t,s,a){t.exports=a.p+"assets/img/1716452700922.7ea262ff.png"},646:function(t,s,a){t.exports=a.p+"assets/img/1716452762720.b2dd501f.png"},647:function(t,s,a){t.exports=a.p+"assets/img/1716453035245.b3168abe.png"},648:function(t,s,a){t.exports=a.p+"assets/img/1716453116447.28b532e9.png"},649:function(t,s,a){t.exports=a.p+"assets/img/1716453295656.869b5db1.png"},650:function(t,s,a){t.exports=a.p+"assets/img/1716473334321.c9344258.png"},651:function(t,s,a){t.exports=a.p+"assets/img/1716473660446.4a472e5f.png"},652:function(t,s,a){t.exports=a.p+"assets/img/1716473673335.a37d643b.png"},653:function(t,s,a){t.exports=a.p+"assets/img/1716474210540.5f177bbc.png"},654:function(t,s,a){t.exports=a.p+"assets/img/1716474237027.8a825d25.png"},8269:function(t,s,a){"use strict";a.r(s);var p=a(5),r=Object(p.a)({},(function(){var t=this,s=t.$createElement,p=t._self._c||s;return p("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[p("h1",{attrs:{id:"_4、内存"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#_4、内存"}},[t._v("#")]),t._v(" 4、内存")]),t._v(" "),p("h4",{attrs:{id:"_1、16进制"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#_1、16进制"}},[t._v("#")]),t._v(" 1、16进制")]),t._v(" "),p("p",[t._v("​\t\t\t16进制 -- 例如我们的图像显示使用的像素RGB颜色值的表示就是使用的16进制")]),t._v(" "),p("p",[t._v("​\t\t16进制最大的值是F=15，如果是FF = 16*15 + 15 = 255")]),t._v(" "),p("h4",{attrs:{id:"为什么要使用这种方式呢-因为我们之前使用的是2进制现在为什么又要使用16进制"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#为什么要使用这种方式呢-因为我们之前使用的是2进制现在为什么又要使用16进制"}},[t._v("#")]),t._v(" 为什么要使用这种方式呢，因为我们之前使用的是2进制现在为什么又要使用16进制？")]),t._v(" "),p("p",[t._v("​\t\t事实证明，16进制只是为了方便而已，为什么，那么如果字母表中有16个数字，从0-F，你需要多少位，多少个0和1来表示16个不同的值？")]),t._v(" "),p("p",[t._v("​\t\t如果是2进制 就需要4位来表达 2的4次方，如果你有一个数字代表4个位，这对于计算机科学家和程序员来说在实践中很方便，虽然使用2进制的1111可以代表16但这不是一个完整的字节，一个字节是8位，没有人以4为单位进行计数，它总是以8、16、32 、64、等8的倍数进行计数，但事实证明因为16进制使用4个bit，所以如果我们使用2个那么就是8个bit，就是一个字节，是常用的计量单位。")]),t._v(" "),p("p",[t._v("​\t\t这就是为什么Photoshop也使用这种约定，颜色程序也是如此，Web开发也是如此一般都是以2个16进制的数字来表示单个字节。")]),t._v(" "),p("p",[t._v("​\t那么关于16进制还有什么问题？")]),t._v(" "),p("h4",{attrs:{id:"_2、内存"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#_2、内存"}},[t._v("#")]),t._v(" 2、内存")]),t._v(" "),p("p",[t._v("​\t\t\t我们在讨论计算机内存的时候，我们将内存中的每个方框单独的位置代表一个字节，所以我们可以计算计算机内部的字节数，正如我们今天在代码中看到的那样，计算机通常使用数字来表示其内存中所有的字节，并且按照惯例，他们通常使用16进制表示法。")]),t._v(" "),p("p",[p("img",{attrs:{src:a(614),alt:"1716429289592"}})]),t._v(" "),p("p",[t._v("​\t\t技术上讲，如果我们像大多数程序员那样开始对他们进行编号并从零开始计数，那么就是这样的效果")]),t._v(" "),p("p",[p("img",{attrs:{src:a(615),alt:"1716429635253"}})]),t._v(" "),p("p",[t._v("​\t我们可能在现实生活中看到例如0x0这样的表达，其实只是在16进制前面加上了0x，这个只是一个约定0x后面的值代表使用的是16进制")]),t._v(" "),p("p",[t._v("​\t"),p("img",{attrs:{src:a(616),alt:"1716429808437"}})]),t._v(" "),p("p",[t._v("我们看一下代码中的变量其实在内存中存放也是有具体位置地址的")]),t._v(" "),p("p",[t._v("​\t\t如果我们真的做数学运算的话，这是一个很大的数值，但是我们不需要关心，我们只是关心它存放于某个地方。代码中使用到的p其实就是使用到了C语言中的指针pointers，指针实际上只是一个地址，某个变量的地址，您甚至可以将其存储在另一个称为指针的变量中。")]),t._v(" "),p("p",[p("img",{attrs:{src:a(617),alt:"1716430155150"}})]),t._v(" "),p("p",[t._v("​\t\t如果指针是地址，我们可以开始修改这个想法，比如我们创建一个变量，该变量的目的不是存储像50数字这样的无聊数字，而是存储某个值的地址")]),t._v(" "),p("p",[p("img",{attrs:{src:a(618),alt:"1716430763796"}})]),t._v(" "),p("p",[t._v("在图形化中我们表达一下，新建的p变量 使用的存储指针那么默认是使用8个字节")]),t._v(" "),p("p",[p("img",{attrs:{src:a(619),alt:"1716431079247"}})]),t._v(" "),p("p",[t._v("​\t\t这对我们来说有什么帮助呢？如果我们更抽象的思考一下这个问题，谁会关心计算机内存中发生了什么？当人们普遍地谈论指针和地址时，人们实际上常常将他们抽象出来，因此在讨论这个问题时，不要在屏幕或白板上写字0x123实际地址是什么，没人在乎实际地址是什么，它的价值就是引导我找到我们关心的实际存储的内容值")]),t._v(" "),p("h4",{attrs:{id:"_3、字符串的实际含义"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#_3、字符串的实际含义"}},[t._v("#")]),t._v(" 3、字符串的实际含义")]),t._v(" "),p("p",[t._v("​\t\t变量s存放的是一个指针地址，而指针的地址指向的是第一个字符最后已 \\0也就是nul结束，这样就完整的读取到内存中的字符串变量了")]),t._v(" "),p("p",[p("img",{attrs:{src:a(620),alt:"1716431848746"}})]),t._v(" "),p("p",[p("img",{attrs:{src:a(621),alt:"1716432275350"}})]),t._v(" "),p("h4",{attrs:{id:"_4、字符串比较"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#_4、字符串比较"}},[t._v("#")]),t._v(" 4、字符串比较")]),t._v(" "),p("p",[t._v("​\t"),p("img",{attrs:{src:a(622),alt:"1716446724021"}})]),t._v(" "),p("p",[t._v("​\t输入相同的内容，但是比较总是显示different")]),t._v(" "),p("p",[p("img",{attrs:{src:a(623),alt:"1716446788710"}})]),t._v(" "),p("p",[t._v("​\t因为不同的原因是他们的内存地址不一致，为什么相同的字符串不使用同一个地址呢，因为面临后续可能修改的问题，所以每个字符串都单独分配一个地址")]),t._v(" "),p("p",[p("img",{attrs:{src:a(624),alt:"1716446985763"}})]),t._v(" "),p("p",[t._v("​\t所以我们在使用compared比较值的时候，那么就相等了")]),t._v(" "),p("p",[p("img",{attrs:{src:a(625),alt:"1716447225063"}})]),t._v(" "),p("p",[t._v("​\t我们在输入相同字符串将内存地址打印后可以看出，内存的地址是不同的，虽然离着很近")]),t._v(" "),p("p",[t._v("​\tb0和f0")]),t._v(" "),p("p",[p("img",{attrs:{src:a(626),alt:"1716447480181"}})]),t._v(" "),p("h4",{attrs:{id:"_5、字符串copy"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#_5、字符串copy"}},[t._v("#")]),t._v(" 5、字符串copy")]),t._v(" "),p("p",[t._v("​\t\t赋值字符串，那么将使用相同的内存地址")]),t._v(" "),p("p",[t._v("​\t如果使用函数malloc的话会重新分配内存")]),t._v(" "),p("p",[p("img",{attrs:{src:a(627),alt:"1716448272322"}})]),t._v(" "),p("p",[t._v("​\t\tmalloc如果一直分配内存不进行释放，那么就会使系统变的庞大 内存也会慢慢堆积不够使用，所以我们要进行内存的释放free函数 -- 在我们使用完成后进行对内存的释放")]),t._v(" "),p("p",[p("img",{attrs:{src:a(628),alt:"1716448640648"}})]),t._v(" "),p("h4",{attrs:{id:"_6、内存检查"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#_6、内存检查"}},[t._v("#")]),t._v(" 6、内存检查")]),t._v(" "),p("p",[t._v("​\t\tvalgrind 是内存检查工具")]),t._v(" "),p("p",[p("img",{attrs:{src:a(629),alt:"1716448814727"}})]),t._v(" "),p("p",[t._v("​\t假设我们自定义内存的使用为 3 * 4 = 12个字节")]),t._v(" "),p("p",[p("img",{attrs:{src:a(630),alt:"1716449300394"}})]),t._v(" "),p("p",[t._v("​\t\t使用valarind检查代码的时候就会提示我们 将会丢失12个字节，因为我们使用malloc而并没有进行释放free")]),t._v(" "),p("p",[p("img",{attrs:{src:a(631),alt:"1716449275289"}})]),t._v(" "),p("p",[t._v("​\t\t代码进行释放")]),t._v(" "),p("p",[p("img",{attrs:{src:a(632),alt:"1716449539942"}})]),t._v(" "),p("p",[t._v("​")]),t._v(" "),p("p",[t._v("​\t\t再次运行，发现不会有内存泄漏的风险 -- 内存泄漏其实就是你之后将找不到这个内存地址，你一直无法将它释放，这块内存地址将一直被使用着")]),t._v(" "),p("p",[p("img",{attrs:{src:a(633),alt:"1716449602316"}})]),t._v(" "),p("p",[p("img",{attrs:{src:a(634),alt:"1716449851057"}})]),t._v(" "),p("h4",{attrs:{id:"_7、垃圾处理garbage"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#_7、垃圾处理garbage"}},[t._v("#")]),t._v(" 7、垃圾处理Garbage")]),t._v(" "),p("p",[t._v("​\t如果我们定义一个1024字节的数组，但从未真正将值放入其中，也没有任何对它的引用")]),t._v(" "),p("p",[t._v("那么这里将有1024个垃圾值，某些情况下会默认初始化值为0，但我们只要不是自己在操作这些值的话那么这些值是不能被信任的")]),t._v(" "),p("p",[p("img",{attrs:{src:a(635),alt:"1716450927270"}})]),t._v(" "),p("p",[p("img",{attrs:{src:a(636),alt:"1716450720699"}})]),t._v(" "),p("h4",{attrs:{id:"_8、swapping-交换值"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#_8、swapping-交换值"}},[t._v("#")]),t._v(" 8、swapping 交换值")]),t._v(" "),p("p",[t._v("​\t\t我们想把x 和y 进行值的交换")]),t._v(" "),p("p",[t._v("​\t\t但是运行代码后发现值并没有发生真正的交换")]),t._v(" "),p("p",[p("img",{attrs:{src:a(637),alt:"1716451370590"}})]),t._v(" "),p("p",[p("img",{attrs:{src:a(638),alt:"1716451544206"}})]),t._v(" "),p("p",[t._v("​\t\t为什么会是这样的效果呢？")]),t._v(" "),p("p",[t._v("​\t\t\t内存分布效果图")]),t._v(" "),p("p",[p("img",{attrs:{src:a(639),alt:"1716451782851"}})]),t._v(" "),p("p",[t._v("我们先了解一下栈 stack")]),t._v(" "),p("p",[t._v("​\t\t当我们执行类似函数操作的时候，我们关注堆栈，例如以下代码")]),t._v(" "),p("p",[p("img",{attrs:{src:a(640),alt:"1716451922113"}})]),t._v(" "),p("p",[t._v("​\t它不允许我们永久的改变这些值，为什么？")]),t._v(" "),p("p",[t._v("​\t在堆栈中的这个main方法，在计算机内存中第一个函数存在的位置，所以主要的是，如果你有任何变量，一旦你加载该程序，他们就会进入计算机内存的底部。")]),t._v(" "),p("p",[p("img",{attrs:{src:a(641),alt:"1716452006762"}})]),t._v(" "),p("p",[t._v("​\t所以当main调用swap时，swap位于栈的上方")]),t._v(" "),p("p",[p("img",{attrs:{src:a(642),alt:"1716452260044"}})]),t._v(" "),p("p",[t._v("​\t而一旦调用完成该内存就会基本消失，或者计算机会忘记它，即使这些位依然存在，而main会一直保留，直到main完成并退出")]),t._v(" "),p("p",[p("img",{attrs:{src:a(643),alt:"1716452424002"}})]),t._v(" "),p("p",[t._v("​\t现在我们考虑一下这些堆栈内部发生了什么")]),t._v(" "),p("p",[t._v("​\t在底部的main中，他有俩个变量 x和 y 分别是1和2")]),t._v(" "),p("p",[p("img",{attrs:{src:a(644),alt:"1716452598541"}})]),t._v(" "),p("p",[t._v("​\t\t内存分布是这样的 swap")]),t._v(" "),p("p",[p("img",{attrs:{src:a(645),alt:"1716452700922"}})]),t._v(" "),p("p",[t._v("​\t\t在swap函数调用完之后是这样的")]),t._v(" "),p("p",[p("img",{attrs:{src:a(646),alt:"1716452762720"}})]),t._v(" "),p("p",[t._v("​\t\t但是并没有在内存中交换x和y的值，我们只是对其副本a和b进行了值的操作，这个交换函数虽然在逻辑上是正确的，但永远不会像编写的逻辑正确的解决这个问题，因为我们一直是在 "),p("strong",[t._v("按值传递")])]),t._v(" "),p("p",[t._v("​\t所以我们可以通过引用传递，通过指针传递也就是内存地址传递")]),t._v(" "),p("p",[p("img",{attrs:{src:a(647),alt:"1716453035245"}})]),t._v(" "),p("p",[p("img",{attrs:{src:a(648),alt:"1716453116447"}})]),t._v(" "),p("p",[p("img",{attrs:{src:a(649),alt:"1716453295656"}})]),t._v(" "),p("h4",{attrs:{id:"_9、io"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#_9、io"}},[t._v("#")]),t._v(" 9、IO")]),t._v(" "),p("p",[t._v("​\t\t文件io，例如可以访问图像文件，文本文件或与文件相关的")]),t._v(" "),p("p",[p("img",{attrs:{src:a(650),alt:"1716473334321"}})]),t._v(" "),p("p",[p("img",{attrs:{src:a(651),alt:"1716473660446"}})]),t._v(" "),p("p",[p("img",{attrs:{src:a(652),alt:"1716473673335"}})]),t._v(" "),p("p",[t._v("​\t\t现在我们再写一个copy的程序")]),t._v(" "),p("p",[p("img",{attrs:{src:a(653),alt:"1716474210540"}})]),t._v(" "),p("p",[t._v("​\t没有问题copy文件成功了")]),t._v(" "),p("p",[p("img",{attrs:{src:a(654),alt:"1716474237027"}})]),t._v(" "),p("p",[t._v("https://www.youtube.com/watch?v=F9-yqoS7b8w")])])}),[],!1,null,null,null);s.default=r.exports}}]);