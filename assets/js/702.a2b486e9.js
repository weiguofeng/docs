(window.webpackJsonp=window.webpackJsonp||[]).push([[702],{8283:function(a,t,r){"use strict";r.r(t);var s=r(5),e=Object(s.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"第二周"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第二周"}},[a._v("#")]),a._v(" 第二周")]),a._v(" "),r("h3",{attrs:{id:"string和stringbuffer、stringbuilder的区别是什么-string为什么是不可变的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#string和stringbuffer、stringbuilder的区别是什么-string为什么是不可变的"}},[a._v("#")]),a._v(" String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？")]),a._v(" "),r("h4",{attrs:{id:"string和stringbuffer、stringbuilder的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#string和stringbuffer、stringbuilder的区别"}},[a._v("#")]),a._v(" String和StringBuffer、StringBuilder的区别")]),a._v(" "),r("p",[r("strong",[a._v("可变性")])]),a._v(" "),r("p",[a._v("简单的来说：String 类中使用 final 关键字字符数组保存字符串，"),r("code",[a._v("private　final　char　value[]")]),a._v("，所以 String 对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串"),r("code",[a._v("char[]value")]),a._v(" 但是没有用 final 关键字修饰，所以这两种对象都是可变的。")]),a._v(" "),r("p",[a._v("StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自行查阅源码。")]),a._v(" "),r("p",[a._v("AbstractStringBuilder.java")]),a._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("abstract class AbstractStringBuilder implements Appendable, CharSequence {\n    char[] value;\n    int count;\n    AbstractStringBuilder() {\n    }\n    AbstractStringBuilder(int capacity) {\n        value = new char[capacity];\n    }\n")])]),a._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[a._v("1")]),r("br"),r("span",{staticClass:"line-number"},[a._v("2")]),r("br"),r("span",{staticClass:"line-number"},[a._v("3")]),r("br"),r("span",{staticClass:"line-number"},[a._v("4")]),r("br"),r("span",{staticClass:"line-number"},[a._v("5")]),r("br"),r("span",{staticClass:"line-number"},[a._v("6")]),r("br"),r("span",{staticClass:"line-number"},[a._v("7")]),r("br"),r("span",{staticClass:"line-number"},[a._v("8")]),r("br")])]),r("p",[r("strong",[a._v("线程安全性")])]),a._v(" "),r("p",[a._v("String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。")]),a._v(" "),r("p",[r("strong",[a._v("性能")])]),a._v(" "),r("p",[a._v("每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。")]),a._v(" "),r("p",[r("strong",[a._v("对于三者使用的总结：")])]),a._v(" "),r("ol",[r("li",[a._v("操作少量的数据 = String")]),a._v(" "),r("li",[a._v("单线程操作字符串缓冲区下操作大量数据 = StringBuilder")]),a._v(" "),r("li",[a._v("多线程操作字符串缓冲区下操作大量数据 = StringBuffer")])]),a._v(" "),r("h4",{attrs:{id:"string为什么是不可变的吗"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#string为什么是不可变的吗"}},[a._v("#")]),a._v(" String为什么是不可变的吗？")]),a._v(" "),r("p",[a._v("简单来说就是String类利用了final修饰的char类型数组存储字符，源码如下图所以：")]),a._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("    /** The value is used for character storage. */\n    private final char value[];\n")])]),a._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[a._v("1")]),r("br"),r("span",{staticClass:"line-number"},[a._v("2")]),r("br")])]),r("h4",{attrs:{id:"string真的是不可变的吗"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#string真的是不可变的吗"}},[a._v("#")]),a._v(" String真的是不可变的吗？")]),a._v(" "),r("p",[a._v("我觉得如果别人问这个问题的话，回答不可变就可以了。\n下面只是给大家看两个有代表性的例子：")]),a._v(" "),r("p",[r("strong",[a._v("1) String不可变但不代表引用不可以变")])]),a._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v('\t\tString str = "Hello";\n\t\tstr = str + " World";\n\t\tSystem.out.println("str=" + str);\n')])]),a._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[a._v("1")]),r("br"),r("span",{staticClass:"line-number"},[a._v("2")]),r("br"),r("span",{staticClass:"line-number"},[a._v("3")]),r("br")])]),r("p",[a._v("结果：")]),a._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("str=Hello World\n")])]),a._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[a._v("1")]),r("br")])]),r("p",[a._v("解析：")]),a._v(" "),r("p",[a._v('实际上，原来String的内容是不变的，只是str由原来指向"Hello"的内存地址转为指向"Hello World"的内存地址而已，也就是说多开辟了一块内存区域给"Hello World"字符串。')]),a._v(" "),r("p",[r("strong",[a._v("2) 通过反射是可以修改所谓的“不可变”对象")])]),a._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v('\t\t// 创建字符串"Hello World"， 并赋给引用s\n\t\tString s = "Hello World";\n\n\t\tSystem.out.println("s = " + s); // Hello World\n\n\t\t// 获取String类中的value字段\n\t\tField valueFieldOfString = String.class.getDeclaredField("value");\n\n\t\t// 改变value属性的访问权限\n\t\tvalueFieldOfString.setAccessible(true);\n\n\t\t// 获取s对象上的value属性的值\n\t\tchar[] value = (char[]) valueFieldOfString.get(s);\n\n\t\t// 改变value所引用的数组中的第5个字符\n\t\tvalue[5] = \'_\';\n\n\t\tSystem.out.println("s = " + s); // Hello_World\n')])]),a._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[a._v("1")]),r("br"),r("span",{staticClass:"line-number"},[a._v("2")]),r("br"),r("span",{staticClass:"line-number"},[a._v("3")]),r("br"),r("span",{staticClass:"line-number"},[a._v("4")]),r("br"),r("span",{staticClass:"line-number"},[a._v("5")]),r("br"),r("span",{staticClass:"line-number"},[a._v("6")]),r("br"),r("span",{staticClass:"line-number"},[a._v("7")]),r("br"),r("span",{staticClass:"line-number"},[a._v("8")]),r("br"),r("span",{staticClass:"line-number"},[a._v("9")]),r("br"),r("span",{staticClass:"line-number"},[a._v("10")]),r("br"),r("span",{staticClass:"line-number"},[a._v("11")]),r("br"),r("span",{staticClass:"line-number"},[a._v("12")]),r("br"),r("span",{staticClass:"line-number"},[a._v("13")]),r("br"),r("span",{staticClass:"line-number"},[a._v("14")]),r("br"),r("span",{staticClass:"line-number"},[a._v("15")]),r("br"),r("span",{staticClass:"line-number"},[a._v("16")]),r("br"),r("span",{staticClass:"line-number"},[a._v("17")]),r("br"),r("span",{staticClass:"line-number"},[a._v("18")]),r("br")])]),r("p",[a._v("结果：")]),a._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("s = Hello World\ns = Hello_World\n")])]),a._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[a._v("1")]),r("br"),r("span",{staticClass:"line-number"},[a._v("2")]),r("br")])]),r("p",[a._v("解析：")]),a._v(" "),r("p",[a._v("用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。")]),a._v(" "),r("h3",{attrs:{id:"什么是反射机制-反射机制的应用场景有哪些"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是反射机制-反射机制的应用场景有哪些"}},[a._v("#")]),a._v(" 什么是反射机制？反射机制的应用场景有哪些？")]),a._v(" "),r("h4",{attrs:{id:"反射机制介绍"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#反射机制介绍"}},[a._v("#")]),a._v(" 反射机制介绍")]),a._v(" "),r("p",[a._v("JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。")]),a._v(" "),r("h4",{attrs:{id:"静态编译和动态编译"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#静态编译和动态编译"}},[a._v("#")]),a._v(" 静态编译和动态编译")]),a._v(" "),r("ul",[r("li",[a._v("**静态编译：**在编译时确定类型，绑定对象")]),a._v(" "),r("li",[a._v("**动态编译：**运行时确定类型，绑定对象")])]),a._v(" "),r("h4",{attrs:{id:"反射机制优缺点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#反射机制优缺点"}},[a._v("#")]),a._v(" 反射机制优缺点")]),a._v(" "),r("ul",[r("li",[r("strong",[a._v("优点：")]),a._v(" 运行期类型的判断，动态加载类，提高代码灵活度。")]),a._v(" "),r("li",[r("strong",[a._v("缺点：")]),a._v(" 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。")])]),a._v(" "),r("h4",{attrs:{id:"反射的应用场景"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#反射的应用场景"}},[a._v("#")]),a._v(" 反射的应用场景")]),a._v(" "),r("p",[a._v("反射是框架设计的灵魂。")]),a._v(" "),r("p",[a._v("在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。")]),a._v(" "),r("p",[a._v("举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中;\n2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性")]),a._v(" "),r("p",[r("strong",[a._v("推荐阅读：")])]),a._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://segmentfault.com/a/1190000010162647?utm_source=tuicool&utm_medium=referral",target:"_blank",rel:"noopener noreferrer"}},[a._v("Reflection：Java反射机制的应用场景"),r("OutboundLink")],1)]),a._v(" "),r("li",[r("a",{attrs:{href:"https://blog.csdn.net/sinat_38259539/article/details/71799078",target:"_blank",rel:"noopener noreferrer"}},[a._v("Java基础之—反射（非常重要）"),r("OutboundLink")],1)])]),a._v(" "),r("h3",{attrs:{id:"什么是jdk-什么是jre-什么是jvm-三者之间的联系与区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是jdk-什么是jre-什么是jvm-三者之间的联系与区别"}},[a._v("#")]),a._v(" 什么是JDK?什么是JRE？什么是JVM？三者之间的联系与区别")]),a._v(" "),r("p",[a._v("这几个是Java中很基本很基本的东西，但是我相信一定还有很多人搞不清楚！为什么呢？因为我们大多数时候在使用现成的编译工具以及环境的时候，并没有去考虑这些东西。")]),a._v(" "),r("p",[r("strong",[a._v("JDK:")]),a._v("  顾名思义它是给开发者提供的开发工具箱,是给程序开发者用的。它除了包括完整的JRE（Java Runtime Environment），Java运行环境，还包含了其他供开发者使用的工具包。")]),a._v(" "),r("p",[r("strong",[a._v("JRE:")]),a._v(" 普通用户而只需要安装JRE（Java Runtime Environment）来运行Java程序。而程序开发者必须安装JDK来编译、调试程序。")]),a._v(" "),r("p",[r("strong",[a._v("JVM：")]),a._v(" 当我们运行一个程序时，JVM负责将字节码转换为特定机器代码，JVM提供了内存管理/垃圾回收和安全机制等。这种独立于硬件和操作系统，正是java程序可以一次编写多处执行的原因。")]),a._v(" "),r("p",[r("strong",[a._v("区别与联系：")])]),a._v(" "),r("ol",[r("li",[a._v("JDK用于开发，JRE用于运行java程序 ；")]),a._v(" "),r("li",[a._v("JDK和JRE中都包含JVM ；")]),a._v(" "),r("li",[a._v("JVM是java编程语言的核心并且具有平台独立性。")])]),a._v(" "),r("h3",{attrs:{id:"什么是字节码-采用字节码的最大好处是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是字节码-采用字节码的最大好处是什么"}},[a._v("#")]),a._v(" 什么是字节码？采用字节码的最大好处是什么？")]),a._v(" "),r("p",[r("strong",[a._v("先看下java中的编译器和解释器：")])]),a._v(" "),r("p",[a._v("Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做"),r("code",[a._v("字节码")]),a._v("（即扩展名为"),r("code",[a._v(".class")]),a._v("的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。这也就是解释了Java的编译与解释并存的特点。")]),a._v(" "),r("p",[a._v("Java源代码----\x3e编译器----\x3ejvm可执行的Java字节码(即虚拟指令)----\x3ejvm----\x3ejvm中解释器-----\x3e机器可执行的二进制机器码----\x3e程序运行。")]),a._v(" "),r("p",[r("strong",[a._v("采用字节码的好处：")])]),a._v(" "),r("p",[a._v("Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。")]),a._v(" "),r("h3",{attrs:{id:"java和c-的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java和c-的区别"}},[a._v("#")]),a._v(" Java和C++的区别")]),a._v(" "),r("p",[a._v("我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！没办法！！！就算没学过C++，也要记下来！")]),a._v(" "),r("ul",[r("li",[a._v("都是面向对象的语言，都支持封装、继承和多态")]),a._v(" "),r("li",[a._v("Java不提供指针来直接访问内存，程序内存更加安全")]),a._v(" "),r("li",[a._v("Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。")]),a._v(" "),r("li",[a._v("Java有自动内存管理机制，不需要程序员手动释放无用内存")])]),a._v(" "),r("h3",{attrs:{id:"接口和抽象类的区别是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#接口和抽象类的区别是什么"}},[a._v("#")]),a._v(" 接口和抽象类的区别是什么？")]),a._v(" "),r("ol",[r("li",[a._v("接口的方法默认是public，所有方法在接口中不能有实现，抽象类可以有非抽象的方法")]),a._v(" "),r("li",[a._v("接口中的实例变量默认是final类型的，而抽象类中则不一定")]),a._v(" "),r("li",[a._v("一个类可以实现多个接口，但最多只能实现一个抽象类")]),a._v(" "),r("li",[a._v("一个类实现接口的话要实现接口的所有方法，而抽象类不一定")]),a._v(" "),r("li",[a._v("接口不能用new实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。")])]),a._v(" "),r("p",[a._v("注意：Java8 后接口可以有默认实现( default )。")]),a._v(" "),r("h3",{attrs:{id:"成员变量与局部变量的区别有那些"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#成员变量与局部变量的区别有那些"}},[a._v("#")]),a._v(" 成员变量与局部变量的区别有那些？")]),a._v(" "),r("ol",[r("li",[a._v("从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public,private,static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；但是，成员变量和局部变量都能被final所修饰；")]),a._v(" "),r("li",[a._v("从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存")]),a._v(" "),r("li",[a._v("从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。")]),a._v(" "),r("li",[a._v("成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被final修饰但没有被static修饰的成员变量必须显示地赋值）；而局部变量则不会自动赋值。")])]),a._v(" "),r("h3",{attrs:{id:"重载和重写的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#重载和重写的区别"}},[a._v("#")]),a._v(" 重载和重写的区别")]),a._v(" "),r("p",[r("strong",[a._v("重载：")]),a._v(" 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。")]),a._v(" "),r("p",[r("strong",[a._v("重写：")]),a._v(" 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为private则子类就不能重写该方法。")]),a._v(" "),r("h3",{attrs:{id:"字符型常量和字符串常量的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#字符型常量和字符串常量的区别"}},[a._v("#")]),a._v(" 字符型常量和字符串常量的区别")]),a._v(" "),r("ol",[r("li",[a._v("形式上:\n字符常量是单引号引起的一个字符\n字符串常量是双引号引起的若干个字符")]),a._v(" "),r("li",[a._v("含义上:\n字符常量相当于一个整形值(ASCII值),可以参加表达式运算\n字符串常量代表一个地址值(该字符串在内存中存放位置)")]),a._v(" "),r("li",[a._v("占内存大小\n字符常量只占一个字节\n字符串常量占若干个字节(至少一个字符结束标志)")])])])}),[],!1,null,null,null);t.default=e.exports}}]);