(window.webpackJsonp=window.webpackJsonp||[]).push([[518],{5859:function(t,s,a){t.exports=a.p+"assets/img/1635608018716.1e000b1e.png"},5860:function(t,s,a){t.exports=a.p+"assets/img/1635608183196.04329774.png"},5861:function(t,s,a){t.exports=a.p+"assets/img/1635608299307.6ff3f2ce.png"},5862:function(t,s,a){t.exports=a.p+"assets/img/1635608429436.f96dbfab.png"},8816:function(t,s,a){"use strict";a.r(s);var n=a(5),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"_4-函数式接口介绍"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-函数式接口介绍"}},[t._v("#")]),t._v(" 4.函数式接口介绍")]),t._v(" "),n("p",[t._v("如果一个接口中只声明了一个抽象方法，则此接口就称为函数式接口。")]),t._v(" "),n("p",[t._v("我们可以在一个接口上使用@FunctionalInterFace注解，这样做可以检查他是否是一个函数式接口")]),t._v(" "),n("p",[t._v("所以以前用匿名实现类表示的现在都可以用Lambda\t表达式来写。")]),t._v(" "),n("p",[t._v("比如Runnable")]),t._v(" "),n("p",[n("img",{attrs:{src:a(5859),alt:"1635608018716"}})]),t._v(" "),n("p",[t._v("其实和abstract没关系，接口中的方法都称为抽象方法，主要是一个方法就为函数式接口，如果不加@FunctionalInterface 也是抽象方法")]),t._v(" "),n("p",[n("img",{attrs:{src:a(5860),alt:"1635608183196"}})]),t._v(" "),n("p",[n("img",{attrs:{src:a(5861),alt:"1635608299307"}})]),t._v(" "),n("p",[n("img",{attrs:{src:a(5862),alt:"1635608429436"}})])])}),[],!1,null,null,null);s.default=e.exports}}]);