(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{5376:function(t,s,a){t.exports=a.p+"assets/img/image-20220410154734819.6ab66cef.png"},5377:function(t,s,a){t.exports=a.p+"assets/img/image-20220410154907512.53d6b28e.png"},5378:function(t,s,a){t.exports=a.p+"assets/img/image-20220410154937690.e01b8b35.png"},5379:function(t,s,a){t.exports=a.p+"assets/img/image-20220410155358788.7abab875.png"},5380:function(t,s,a){t.exports=a.p+"assets/img/image-20220410160151213.0d12054e.png"},5381:function(t,s,a){t.exports=a.p+"assets/img/image-20220410160407380.8c307624.png"},5382:function(t,s,a){t.exports=a.p+"assets/img/image-20220410160645578.c330af48.png"},5383:function(t,s,a){t.exports=a.p+"assets/img/image-20220410160734746.fba46dd5.png"},5384:function(t,s,a){t.exports=a.p+"assets/img/image-20220410161045197.29257a64.png"},5385:function(t,s,a){t.exports=a.p+"assets/img/image-20220410161417069.b43ae5e9.png"},5386:function(t,s,a){t.exports=a.p+"assets/img/image-20220410161526212.dc4efc10.png"},5387:function(t,s,a){t.exports=a.p+"assets/img/image-20220410161913680.0d71d10b.png"},5388:function(t,s,a){t.exports=a.p+"assets/img/image-20220410162102405.86b385c9.png"},5389:function(t,s,a){t.exports=a.p+"assets/img/image-20220410162256110.ae5f5ee1.png"},5390:function(t,s,a){t.exports=a.p+"assets/img/image-20220410162416411.9b6a2d05.png"},5391:function(t,s,a){t.exports=a.p+"assets/img/image-20220410162435521.323ecec3.png"},5392:function(t,s,a){t.exports=a.p+"assets/img/image-20220410163717964.f8c1c289.png"},5393:function(t,s,a){t.exports=a.p+"assets/img/image-20220410164153750.06c15bd1.png"},5394:function(t,s,a){t.exports=a.p+"assets/img/image-20220410164304031.105d678a.png"},5395:function(t,s,a){t.exports=a.p+"assets/img/image-20220410164336247.7080201a.png"},5396:function(t,s,a){t.exports=a.p+"assets/img/image-20220410165100701.963ff0d7.png"},5397:function(t,s,a){t.exports=a.p+"assets/img/image-20220410165324701.fc4ea583.png"},5398:function(t,s,a){t.exports=a.p+"assets/img/image-20220410165753036.25bb57e4.png"},5399:function(t,s,a){t.exports=a.p+"assets/img/image-20220410165853780.4fecb292.png"},5400:function(t,s,a){t.exports=a.p+"assets/img/image-20220410165940810.22be2b46.png"},5401:function(t,s,a){t.exports=a.p+"assets/img/image-20220410170353518.35088604.png"},5402:function(t,s,a){t.exports=a.p+"assets/img/image-20220410170414214.31f5c23d.png"},5403:function(t,s,a){t.exports=a.p+"assets/img/image-20220410170751048.abce2888.png"},5404:function(t,s,a){t.exports=a.p+"assets/img/image-20220410170845038.074d71eb.png"},5405:function(t,s,a){t.exports=a.p+"assets/img/image-20220410170915897.8e01f981.png"},5406:function(t,s,a){t.exports=a.p+"assets/img/image-20220410171051403.326e7452.png"},5407:function(t,s,a){t.exports=a.p+"assets/img/image-20220410171326196.886baebd.png"},8617:function(t,s,a){"use strict";a.r(s);var e=a(5),i=Object(e.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"_24-比较对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_24-比较对象"}},[t._v("#")]),t._v(" 24.比较对象")]),t._v(" "),e("p",[t._v("​\t\tcomparing Objects：比较对象")]),t._v(" "),e("p",[t._v("​\t下面我们会讨论比较对象，我们新建一个Point对象")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5376),alt:"image-20220410154734819"}})]),t._v(" "),e("p",[t._v("​\t然后我们创建2个点对象的实例，设置一样的字段值，我们比较一下他们")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5377),alt:"image-20220410154907512"}})]),t._v(" "),e("p",[t._v("​\t结果是false--因为这俩个点对象都是引用类型，所以存储在这些变量中的是Point对象的内存地址，他们是不同的地址所以就是false")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5378),alt:"image-20220410154937690"}})]),t._v(" "),e("p",[t._v("​\t如果我们使用equals呢？我们会得到相同的结果，因为equals该方法的默认实现Object类中是根据俩个对象的引用来比较他们的")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5379),alt:"image-20220410155358788"}})]),t._v(" "),e("p",[t._v("​\t现在如果我们想使用内容做为比较对象的话，就需要重写equals方法，改变他的实现，让他比较Point的内容根据坐标进行比较。")]),t._v(" "),e("p",[t._v("​\t我们重写一下equals方法，我们使用ide的Generate自动生成一下")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5380),alt:"image-20220410160151213"}})]),t._v(" "),e("p",[t._v("​\t但我们还不想这样做，我们想覆盖方法，我们就选择Override Methods")]),t._v(" "),e("p",[t._v("​\t"),e("img",{attrs:{src:a(5381),alt:"image-20220410160407380"}})]),t._v(" "),e("p",[t._v("​\t然后我们选择equals方法")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5382),alt:"image-20220410160645578"}})]),t._v(" "),e("p",[t._v("​\tintellij idea 为我们自动生成了代码，并添加了注释")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5383),alt:"image-20220410160734746"}})]),t._v(" "),e("p",[t._v("​\t现在我们想改变这个实现，如果我们改变接收参数为我们需要的类型的话，会发生报错，就不会覆盖到父类Object的equlas方法，显然接收参数是不可变的")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5384),alt:"image-20220410161045197"}})]),t._v(" "),e("p",[t._v("​\t所以我们应该在方法内部进行处理，我们进行向下转型，将Object转为Point，这样我们就可以进行Point对象的内容 如x，y坐标进行比较了")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5385),alt:"image-20220410161417069"}})]),t._v(" "),e("p",[t._v("​\t我们运行一下程序，看一下结果：为true，这正是我们想要的结果")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5386),alt:"image-20220410161526212"}})]),t._v(" "),e("p",[t._v("​\t我们的实现有个问题，因为这个参数是Object类型，我们可以将任何类型对象传递给这个方法， 所以我们强制转换类型就需要确定保证传入过来的类型，否则就会出现类型转换异常")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5387),alt:"image-20220410161913680"}})]),t._v(" "),e("p",[t._v("​\t我们值需要添加一个判断就可以了 判断是否为Point也就是我们需要转换的类型实例")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5388),alt:"image-20220410162102405"}})]),t._v(" "),e("p",[t._v("我们还可以简化一下代码：")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5389),alt:"image-20220410162256110"}})]),t._v(" "),e("p",[t._v("​\t如果我们将一个对象与他自身比较会发生什么？")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5390),alt:"image-20220410162416411"}})]),t._v(" "),e("p",[t._v("返回true,我们的重写equals方法仍然有效")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5391),alt:"image-20220410162435521"}})]),t._v(" "),e("p",[t._v("​\t\t我们可以应用优化技术，优化一下代码，现在是我们通过 对象的字段值的引用 进行的比较使用的==符号， ==是比较引用地址是否相同")]),t._v(" "),e("p",[t._v("​\t\t我们通过他们的引用，如果他们引用的是同一个对象，那么就说明这俩个点是相等的，所以，我们可以加一个判断 this == obj 传入对象obj和当前对象使用同样的引用地址那么就是同一个对象")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5392),alt:"image-20220410163717964"}})]),t._v(" "),e("p",[t._v("​\t现在作为一种最佳实践，每当我们重写equlas方法时，我们也应该重写hashCode方法")]),t._v(" "),e("h4",{attrs:{id:"重写hashcode方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重写hashcode方法"}},[t._v("#")]),t._v(" 重写hashCode方法")]),t._v(" "),e("p",[t._v("​\t"),e("img",{attrs:{src:a(5393),alt:"image-20220410164153750"}})]),t._v(" "),e("p",[e("img",{attrs:{src:a(5394),alt:"image-20220410164304031"}})]),t._v(" "),e("p",[t._v("生成如下代码：原始的是在Object基类中调用hashCode方法，我们不希望这样，我们希望根据此对象的内容，基于 x和y字段的值生成hashCode值")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5395),alt:"image-20220410164336247"}})]),t._v(" "),e("p",[t._v("​\t怎么做呢？很简单，我们有一个叫做objects的类，是java utils工具包下的对象")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5396),alt:"image-20220410165100701"}})]),t._v(" "),e("p",[t._v("​\tObjects类有一个生成hashCode的方法 hash（），我们可以给他一组的值，他会进行映射，最后返回一个int类型的hashCode值，理论上hash是唯一标识，其实Objects他不是100%的完全准确，但他对99%是准确的")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5397),alt:"image-20220410165324701"}})]),t._v(" "),e("p",[t._v("​\t现在我们调用hash方法并传入俩个值x和y")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5398),alt:"image-20220410165753036"}})]),t._v(" "),e("p",[t._v("​\t现在我们回到main方法，测试一下")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5399),alt:"image-20220410165853780"}})]),t._v(" "),e("p",[t._v("​\t我们可以看到得到是同样的hashCode值，这是基于对象内容的hashCode值，相比之下hashcode方法的默认实现生成的hash是基于内存中对象的地址")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5400),alt:"image-20220410165940810"}})]),t._v(" "),e("p",[t._v("​\t所以如果我们的point注释掉这段重写的hashCode，我们看一下他原始的是什么")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5401),alt:"image-20220410170353518"}})]),t._v(" "),e("p",[t._v("​\t可以看到他们是不同的，因为内存中对象引用的地址不同")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5402),alt:"image-20220410170414214"}})]),t._v(" "),e("p",[t._v("​\t现在我们看一个很酷的把戏，以上我们手动覆盖了equals和hashCode方法，我们可以使用Intellij idea为我们生成整个代码")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5403),alt:"image-20220410170751048"}})]),t._v(" "),e("p",[t._v("然后我们选择生成代码的模板--我们默认下一步就可以了")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5404),alt:"image-20220410170845038"}})]),t._v(" "),e("p",[t._v("然后选择字段--就是需要做对象比较的指标字段")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5405),alt:"image-20220410170915897"}})]),t._v(" "),e("p",[t._v("​\t这就是自动生成的equals")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5406),alt:"image-20220410171051403"}})]),t._v(" "),e("p",[t._v("自动生成的hashCode方法")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5407),alt:"image-20220410171326196"}})]),t._v(" "),e("p",[t._v("以上内容是很重要的")]),t._v(" "),e("p",[t._v("需要明白：==和equals的区别")]),t._v(" "),e("p",[t._v("1）对于==，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；")]),t._v(" "),e("p",[t._v("如果作用于引用类型的变量，则比较的是所指向的对象的地址")]),t._v(" "),e("p",[t._v("2）对于equals方法，注意：equals方法不能作用于基本数据类型的变量")]),t._v(" "),e("p",[t._v("如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；")]),t._v(" "),e("p",[t._v("诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。")]),t._v(" "),e("p",[t._v("https://www.bilibili.com/video/BV1Su411X7Bb?p=39&spm_id_from=pageDriver")])])}),[],!1,null,null,null);s.default=i.exports}}]);