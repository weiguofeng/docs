(window.webpackJsonp=window.webpackJsonp||[]).push([[303],{5976:function(t,s,a){t.exports=a.p+"assets/img/image-20220410203558928.c507b1f4.png"},5977:function(t,s,a){t.exports=a.p+"assets/img/image-20220410203933257.926b2402.png"},5978:function(t,s,a){t.exports=a.p+"assets/img/image-20220410204253127.fa12aa8b.png"},5979:function(t,s,a){t.exports=a.p+"assets/img/image-20220410204423154.d0464f77.png"},5980:function(t,s,a){t.exports=a.p+"assets/img/image-20220410205154759.3a3dc5c2.png"},5981:function(t,s,a){t.exports=a.p+"assets/img/image-20220410211425206.c791ba6e.png"},5982:function(t,s,a){t.exports=a.p+"assets/img/image-20220410210536567.ce8c8413.png"},5983:function(t,s,a){t.exports=a.p+"assets/img/image-20220410211822820.b260a5f7.png"},5984:function(t,s,a){t.exports=a.p+"assets/img/image-20220410211930984.f46dd6ab.png"},5985:function(t,s,a){t.exports=a.p+"assets/img/image-20220410212910466.1cf0684e.png"},5986:function(t,s,a){t.exports=a.p+"assets/img/image-20220410213603481.84e95e78.png"},9344:function(t,s,a){"use strict";a.r(s);var e=a(5),i=Object(e.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"_25-多态性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_25-多态性"}},[t._v("#")]),t._v(" 25.多态性")]),t._v(" "),e("p",[t._v("​\t\t\tPolymorphism:多态性")]),t._v(" "),e("p",[t._v("​\t我们已经了解了面向对象的三个原则，封装，抽象，继承")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5976),alt:"image-20220410203558928"}})]),t._v(" "),e("p",[t._v("​\t下面我们讨论一下第四个原则，多态性，poly - morph -ism 很多时候morph意思是形式，多态性，意味着多种形式，这是面向对象编程语言的特点之一，这使得一个对象可以有不同的形式，这是非常强大的")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5977),alt:"image-20220410203933257"}})]),t._v(" "),e("p",[t._v("我们新建一个复选框的类checkbox")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5978),alt:"image-20220410204253127"}})]),t._v(" "),e("p",[t._v("我们在main方法中，声明一个UIControl的数组，里面放文本对象，再放一个复选框对象")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5979),alt:"image-20220410204423154"}})]),t._v(" "),e("p",[t._v("因此，假设现在想要呈现一个具有多个控制对象的窗体，你可以有几个文本框，复选框，单选按钮等等，现在如果要以程序方式渲染不同的控制对象，我们最终会编写这样的代码，我们迭代这个数组，然后内部判断如果这个控件是文本框，那么就渲染文本框内容，然后如果是复选框就渲染复选框的内容等等。")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5980),alt:"image-20220410205154759"}})]),t._v(" "),e("p",[t._v("​\t所以这是程序性的解决问题，问题是我们最终会有一个大的问题，就是每次我们声明一个扩展的新类的时候，对于UI控件，我们必须回到这里并修改这个if语句，这就是我们应用面向对象的多态性原理的地方")]),t._v(" "),e("p",[t._v("​\t现在我们进入我们的UIControl类中，我们编写一个渲染方法render()，在这个方法中，我们不会有任何实现，因为我们不知道如何呈现控件，这取决于他是什么控件，因为对于不同的控件就有不同的计算方法，所以我们把这个默认实现留空")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5981),alt:"image-20220410211425206"}})]),t._v(" "),e("p",[t._v("​\t但是现在我们可以转到我们的每个子类并重写这个方法，那么我们转到文本框对象中，我们覆盖一下父类的render渲染方法")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5982),alt:"image-20220410210536567"}})]),t._v(" "),e("p",[t._v("​\t让我们渲染一下，比如输出一段内容")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5983),alt:"image-20220410211822820"}})]),t._v(" "),e("p",[t._v("同样我们也操作一下CheckBox")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5984),alt:"image-20220410211930984"}})]),t._v(" "),e("p",[t._v("​\t每个控件现在都有自己的渲染方法，这也是封装原则在起作用，所以我们将数据和所有操作捆绑在一起，围绕单个单元中的数据，而不是十种渲染方法，每次进行判断后进行分支处理然后渲染等等")]),t._v(" "),e("p",[t._v("​\t现在我们回到main方法中，然后我们遍历ui控件，然后control点render方法，这就是多态性的作用")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5985),alt:"image-20220410212910466"}})]),t._v(" "),e("p",[t._v("​\tUI控件是一个数组，在运行的时候，我们需要插入不同的对象，目前第一个元素是文本框，第二个元素是复选框对象，显然当我们遍历这个数组时，有一个复选框，处理不同的类型对象，每个对象都有自己的渲染方法，这就是我们现在的UI控件对象有许多不同的形式工作方式，这就是多态性。")]),t._v(" "),e("p",[t._v("​\t我们运行一下程序看一下，正如我们所看到的每个控件对象都在控制台渲染了自己")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5986),alt:"image-20220410213603481"}})])])}),[],!1,null,null,null);s.default=i.exports}}]);