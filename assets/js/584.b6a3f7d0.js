(window.webpackJsonp=window.webpackJsonp||[]).push([[584],{6554:function(t,s,o){t.exports=o.p+"assets/img/1650769129939.756eebee.png"},6555:function(t,s,o){t.exports=o.p+"assets/img/1650769880595.33305277.png"},6556:function(t,s,o){t.exports=o.p+"assets/img/1650770152854.c1743fcb.png"},8858:function(t,s,o){"use strict";o.r(s);var p=o(5),e=Object(p.a)({},(function(){var t=this,s=t.$createElement,p=t._self._c||s;return p("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[p("h1",{attrs:{id:"_17-k8s核心实战-理解pod"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#_17-k8s核心实战-理解pod"}},[t._v("#")]),t._v(" 17.k8s核心实战-理解pod")]),t._v(" "),p("h4",{attrs:{id:"_1-pod是什么"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#_1-pod是什么"}},[t._v("#")]),t._v(" 1.Pod是什么？")]),t._v(" "),p("p",[t._v("​\t在docker中我们运行的应用称为容器，在k8s中我们称为pod，这个pod和容器有什么样的关系呢？其实就是k8s在我们的docker容器之上又封装了一层叫pod，因为这样k8s才可以方便的管理容器，k8s不是直接操作容器的，而是把容器封装一层为pod，那么以后k8s就不叫启动或者停止一个容器了，而是启动或者停止一个pod")]),t._v(" "),p("p",[p("img",{attrs:{src:o(6554),alt:"1650769129939"}})]),t._v(" "),p("p",[t._v("​\t如果我们运行中的这些容器如 redis Container比作为打工人，而pod可以比作员工宿舍，那么我们以后集团管理员工就是以宿舍为单位，上图每个pod里面都有一个容器，是可以有多个的，pod是运行中的一组容器。")]),t._v(" "),p("p",[t._v("​\tpod与pod之间是互相隔离的，其中一个pod有问题，不会影响到另外的pod")]),t._v(" "),p("p",[t._v("例如，这个图有一个文件下载容器，还有一个web服务容器，他们共同组成一个pod")]),t._v(" "),p("p",[p("img",{attrs:{src:o(6555),alt:"1650769880595"}})]),t._v(" "),p("p",[t._v("这也就是为什么我们在使用命令查看pod的时候ready会显示 1/1这样或者2/2等等，其实就是一个pod中可能存在多个容器---只有我们的pod里面所有的容器都正常工作这个pod才算正常的pod")]),t._v(" "),p("p",[p("img",{attrs:{src:o(6556),alt:"1650770152854"}})])])}),[],!1,null,null,null);s.default=e.exports}}]);