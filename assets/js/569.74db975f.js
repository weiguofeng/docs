(window.webpackJsonp=window.webpackJsonp||[]).push([[569],{5478:function(t,e,a){t.exports=a.p+"assets/img/image-20220412212856444.99cc882a.png"},5479:function(t,e,a){t.exports=a.p+"assets/img/image-20220412215758183.9e8ce9c2.png"},5480:function(t,e,a){t.exports=a.p+"assets/img/image-20220412220835436.c6345ea2.png"},8717:function(t,e,a){"use strict";a.r(e);var s=a(5),v=Object(s.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"_30-什么是接口"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_30-什么是接口"}},[t._v("#")]),t._v(" 30.什么是接口？")]),t._v(" "),s("p",[t._v("​\t关于接口是最容易被误解的Java特性，部分原因是人们并不真正了解接口的真正目的。")]),t._v(" "),s("p",[t._v("​\t从Java8开始，我们看一下原始的和现在的接口的用途，然后我们来看看这是如何变化的，过去几年，我们使用接口来couple，ostensible，和testable可测试 的应用程序，这是什么原始呢？")]),t._v(" "),s("p",[t._v("​\t在之前我们讨论了耦合，这是俩个实体之间的依赖关系，比如类，如果A类使用B类，我们说是A依赖B ，如果我们改变B，我们可能需要改变A中的代码，以及依赖A的所有其他类，即使代码中没有任何破坏性的更改，仅仅是因为B更改后，他必须重新编译，这意味着每一个依赖于B，并且应该重新编译他们的依赖关系，重新部署后，这在一个具有几个类的应用程序不复杂，但如果是在一个有数百个类或更多的大型复杂应用中，我们不希望简单的改变就导致在多个地方发生大量级联的，破坏性的变化，我们不想修改一行代码，等待几秒钟的重新编译时间，所以为了防止这些，我们应该努力保持我们的类之间的耦合或关系尽可能松散。")]),t._v(" "),s("p",[s("img",{attrs:{src:a(5478),alt:"image-20220412212856444"}})]),t._v(" "),s("p",[t._v("​\t我们想象一下，如果你的车，如果在引擎里的一个内部零件，我们想换掉这个零件，我们总不能更换轮胎把，这没有意义，这就是松耦合")]),t._v(" "),s("p",[t._v("​\t那么如何减少俩个类之间的耦合？之前我们讨论了面向对象编程，我们应该隐藏类的实现细节，只公开必要的内容，所以通过private关键字隐藏某些成员，这样A和B 的关联就会减少，这会降低耦合度，但这还不够，那就是接口起到了拯救的作用，有了接口我们完全可以将A和B分离，这样他就完全不用关注他了，好像他根本不存在，如果我们改变B，A是不会受到影响的。")]),t._v(" "),s("p",[t._v("​\t现在接口到底是什么？接口是一种类似于类的类型，它只包括方法声明，没有实现的代码，它只定义类应该具有的功能。")]),t._v(" "),s("p",[t._v("​\t例如：我们有一个餐厅，需要一位厨师，我们不在乎厨师是谁，只要他有一定的能力就可以，这就是松耦合的例子，如果你的厨师出了什么事情决定不来上班，我们可以用其他有同样能力的人们替代他们。")]),t._v(" "),s("p",[s("img",{attrs:{src:a(5479),alt:"image-20220412215758183"}})]),t._v(" "),s("p",[t._v("​\t如，我们在A和B之间放置一个接口，将他们分离，现在如果改变B中的代码，A不会受到影响，因为他对B一无所知，我们称为针对接口编程，所以我们把我们的类编码为接口，而不是具体实现，我们可以用他来构建松散耦合且广泛的应用程序，之后我们可以很容易的用另外一个实现这个接口的类替换B，这使得扩展我们的应用程序相对容易")]),t._v(" "),s("p",[t._v("​\t例如：假设我们明天使用B来执行人脸识别，后天我们使用另一个做的更换的C实现来替换B的工作在人脸识别方面，这会更快更准确。在不影响应用程序其余部分的情况下，我们只是用一个类替换了另一个类，只要这俩个类都遵循我们的合同或接口。")]),t._v(" "),s("p",[t._v("​\t因此，一个接口提供了该项目应该做什么，实现该接口的类决定了是如何做到的。")]),t._v(" "),s("p",[t._v("​\t任何我们需要灵活交换的地方都可以使用接口来提升我们的设计。")]),t._v(" "),s("p",[s("img",{attrs:{src:a(5480),alt:"image-20220412220835436"}})]),t._v(" "),s("p",[t._v("​\t例如：我们正在构建一个应用程序，用于计算税收，每年税收规则都可能发生变化，但是每年你都需要计算税收，所以如果你的接口指定了应该做什么，即 计算税收，不同的类别将提供不同的计算方法，每年我们都可以解决一个实现和另一个实现的问题。")]),t._v(" "),s("p",[t._v("​\t所以接口是关于做什么的，而类是关于如何做的。")]),t._v(" "),s("p",[t._v("​\t通过接口，我们可以构建松散耦合的应用程序，而且范围广泛，他们可以很容易的扩展或更换各部件。对我们的应用程序的影响最小或为0.我们还可以独立测试这一部分，确保他们正常工作。这就是我们所说的单元测试，这就是使用接口的真正目的。")])])}),[],!1,null,null,null);e.default=v.exports}}]);