(window.webpackJsonp=window.webpackJsonp||[]).push([[455],{4614:function(s,n,a){s.exports=a.p+"assets/img/1624937991953.41104368.png"},4615:function(s,n,a){s.exports=a.p+"assets/img/1624937791466.1211511f.png"},4616:function(s,n,a){s.exports=a.p+"assets/img/1624937915433.92a35760.png"},4617:function(s,n,a){s.exports=a.p+"assets/img/1624963104437.e3c91b35.png"},4618:function(s,n,a){s.exports=a.p+"assets/img/1624965654266.7d6843bc.png"},8589:function(s,n,a){"use strict";a.r(n);var t=a(5),e=Object(t.a)({},(function(){var s=this,n=s.$createElement,t=s._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"怎么保证redis是高并发以及高可用的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#怎么保证redis是高并发以及高可用的"}},[s._v("#")]),s._v(" 怎么保证redis是高并发以及高可用的？")]),s._v(" "),t("h4",{attrs:{id:"_1-面试题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-面试题"}},[s._v("#")]),s._v(" 1.面试题")]),s._v(" "),t("p",[s._v("​\t"),t("strong",[s._v("怎么保证redis是高并发和高可用？redis的主从复制原理可以介绍一下吗？redis的哨兵原理能介绍一下吗？")])]),s._v(" "),t("h4",{attrs:{id:"_2-面试官心里分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-面试官心里分析"}},[s._v("#")]),s._v(" 2.面试官心里分析")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("\t其实这个问题，主要是考考你，redis单机能承载多少高并发？如果单机抗不住如何扩容抗更多的并发？redis会不会挂？既然会挂怎么保证redis是高可用的？\n\t\n\t其实针对的都是项目中你肯定要考虑的一些问题，如果你没考虑过，那确实你对生产系统中的问题思考太少了。\n\t\n\t\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br")])]),t("h4",{attrs:{id:"_3-面试题剖析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-面试题剖析"}},[s._v("#")]),s._v(" 3.面试题剖析")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("\t就是如果你用redis技术的话，肯定要考虑如何用redis来加多台机器，保证redis是高并发的，还有就是如何让redis保证自己不是挂掉以后就直接死掉了，redis高可用。\n\t\n\t一般单机redis可以承载大约1万到几万的QPS。如果想让redis承载10万或者更高的并发，那么思路是读写分离。\n\t一般来说，对缓存，一般都是用来支撑读高并发的，写的请求是比较少的，可能写的请求也就是 1秒钟几千，大量的请求都是读，1秒钟20万的读。\n\t\n\tredis高并发回答：使用读写分离 一个主多个重的架构方案，master slave，slave用于读，master用于写。单主用来写入数据，单机几万QPS，多从用来查询数据。多个实例可以提供每秒10万QPS。\n\t\n\tredis高并发的同时，还需要容纳大量的数据：一主多从，每个实例都容纳了完整的数据，比如redis主就10G的内存量，其实你就最多只能容纳10G的数据量，如果你的缓存要容纳的数据量很大，达到了几十G，甚至几百G，或者几T，那你就需要redis集群，而且redis集群之后，可以提供可能每秒几十万的读写并发。\n\t\n\t\n\t\n\tredis高可用回答：如果你做主从架构部署，其实就是加上哨兵就可以了，就可以任何一个实例宕机，自动会进入主备切换。\n\t\n\t\n\t\n\t\n\t主从架构 -> 读写分离 -> 支撑10万+读QPS的架构\n\n\t4、接下来要讲解的一个topic\n\n\t\tredis replication\n\n\t\tredis主从架构 -> 读写分离架构 -> 可支持水平扩展的读高并发架构\n\t\n\t\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br"),t("span",{staticClass:"line-number"},[s._v("18")]),t("br"),t("span",{staticClass:"line-number"},[s._v("19")]),t("br"),t("span",{staticClass:"line-number"},[s._v("20")]),t("br"),t("span",{staticClass:"line-number"},[s._v("21")]),t("br"),t("span",{staticClass:"line-number"},[s._v("22")]),t("br"),t("span",{staticClass:"line-number"},[s._v("23")]),t("br"),t("span",{staticClass:"line-number"},[s._v("24")]),t("br"),t("span",{staticClass:"line-number"},[s._v("25")]),t("br")])]),t("p",[t("strong",[s._v("redis单机的瓶颈")])]),s._v(" "),t("p",[t("img",{attrs:{src:a(4614),alt:"1624937991953"}})]),s._v(" "),t("p",[t("strong",[s._v("redis读写分离主从架构图：")])]),s._v(" "),t("p",[t("img",{attrs:{src:a(4615),alt:"1624937791466"}})]),s._v(" "),t("p",[t("img",{attrs:{src:a(4616),alt:"1624937915433"}})]),s._v(" "),t("h4",{attrs:{id:"_4-redis-replication基本原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-redis-replication基本原理"}},[s._v("#")]),s._v(" 4.redis replication基本原理")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("\t1.图解redis replication基本原理\n\t\t其实就是将主master节点的数据 复制（同步） 到 slave 从节点上，并且是异步进行的。\n\t\n\t2.redis replication的核心机制\n\t\t2.1： redis采用异步方式复制数据到slave节点，不过redis 2.8版本开始，slave node会周期性地确认自己每次复制的数据量。\n\t\t2.2： 一个master node是可以配多个slave node的\n\t\t2.3： slave node 也可以连接其他的 slave node\n\t\t2.4： slave node 做复制的时候，是不会block（阻塞） master node 的正常工作的。\n\t\t2.5： slave node 在做复制的时候，也不会block对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了。\n\t\t2.6： slave node 主要用来进行横向扩容，扩容的slave node 可以提高吞吐量。实现高并发。\n\t\n\t3.master持久化对于主从架构的安全保障的意义\n\t\t3.1： 如果采用了主从架构，那么建议必须开启master node的持久化\n\t\t\n\t\t3.2： 不建议使用 slave node作为master node的数据热备，因为那样的话，如果你关掉master的持久化，可能在master宕机重启的时候数据是空的，然后可能一经过复制，slave node的数据也丢了。\n\t\t\tmaster-》RDB和AOF都关闭了--》数据全部在内存中\n\t\t\tmaster宕机，重启，是没有本地数据可以恢复的，然后就会直接认为自己的IDE数据是空的\n\t\t\tmaster就会将空的数据集同步到slave节点上去，所有的slave的数据被清空\n\t\t\t100%的数据丢失\n\t\t\tmaster节点必须使用持久化机制\n\t\t\tmaster的各种备份方案，要不要做，万一说本地所有文件丢失了；从备份中挑选一份rdb去回复master，这样才能确保master启动的时候，是有数据的。\n\t\t\t\n\t即使采用后续讲解的高可用机制，slave node可以自动接管 master node，但是也可能sentinal（哨兵） 还没有检测到master failure（宕机），master node就自动重启了，还是可能导致上面所有的slave node数据清空故障。\n\t\t\t\n\t\t\t\n\t\t\n\t\n\t\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br"),t("span",{staticClass:"line-number"},[s._v("18")]),t("br"),t("span",{staticClass:"line-number"},[s._v("19")]),t("br"),t("span",{staticClass:"line-number"},[s._v("20")]),t("br"),t("span",{staticClass:"line-number"},[s._v("21")]),t("br"),t("span",{staticClass:"line-number"},[s._v("22")]),t("br"),t("span",{staticClass:"line-number"},[s._v("23")]),t("br"),t("span",{staticClass:"line-number"},[s._v("24")]),t("br"),t("span",{staticClass:"line-number"},[s._v("25")]),t("br"),t("span",{staticClass:"line-number"},[s._v("26")]),t("br"),t("span",{staticClass:"line-number"},[s._v("27")]),t("br"),t("span",{staticClass:"line-number"},[s._v("28")]),t("br")])]),t("p",[t("strong",[s._v("redis replication")])]),s._v(" "),t("p",[t("img",{attrs:{src:a(4617),alt:"1624963104437"}})]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("1.主从架构核心原理\n\t当启动一个slave node的时候，他会发送一个PSYNC命令给master node\n\t如果这是slave node重新连接master node，那么master仅仅会复制给slave部分缺少的数据，否则如果是slave第一次连接master，那么会触发一次full resynchronization(生成RDB文件发送给slave，slave先存入磁盘然后再从磁盘中读取到slave中)\n\t\n\t开始full resynchronization的时候，master会启动一个后台线程，开始生成一份RDB快照文件，同时还会将从客户端收到的所有写命令缓存在内存中。RDB文件生成完毕之后，master会将这个RDB发送给slave，slave会先写入本地磁盘，然后再从本地磁盘加载到内存中。然后master会将内存中缓存的写命令发送给slave，slave也会同步这些数据。\n\tslave node如果跟master node有网络故障，断开了连接，会自动重连。master如果发现有多个slave node都来重新连接，仅仅会启动一个rdb save操作，用一份数据服务所有slave node。\n\n\n\n2.主从复制的端点续传\n\t从redis 2.8开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份\n\n\tmaster node会在内存中常见一个backlog，master和slave都会保存一个replica offset还有一个master id，offset就是保存在backlog中的。如果master和slave网络连接断掉了，slave会让master从上次的replica offset开始继续复制\n\n\t但是如果没有找到对应的offset，那么就会执行一次resynchronization（全量复制）\n\t\n\t\n\t\n3、无磁盘化复制\n\n    master在内存中直接创建rdb，然后发送给slave，不会在自己本地落地磁盘了\n\n    repl-diskless-sync（配置在6379.conf中）\n    repl-diskless-sync-delay，等待一定时长再开始复制，因为要等更多slave重新连接过来\n\n4、过期key处理\n\n\tslave不会过期key，只会等待master过期key。如果master过期了一个key，或者通过LRU淘汰了一个key，那么会模拟一条del命令发送给slave。\t\n\t\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br"),t("span",{staticClass:"line-number"},[s._v("18")]),t("br"),t("span",{staticClass:"line-number"},[s._v("19")]),t("br"),t("span",{staticClass:"line-number"},[s._v("20")]),t("br"),t("span",{staticClass:"line-number"},[s._v("21")]),t("br"),t("span",{staticClass:"line-number"},[s._v("22")]),t("br"),t("span",{staticClass:"line-number"},[s._v("23")]),t("br"),t("span",{staticClass:"line-number"},[s._v("24")]),t("br"),t("span",{staticClass:"line-number"},[s._v("25")]),t("br"),t("span",{staticClass:"line-number"},[s._v("26")]),t("br"),t("span",{staticClass:"line-number"},[s._v("27")]),t("br"),t("span",{staticClass:"line-number"},[s._v("28")]),t("br"),t("span",{staticClass:"line-number"},[s._v("29")]),t("br")])]),t("p",[t("strong",[s._v("redis主从复制的原理图")])]),s._v(" "),t("p",[t("img",{attrs:{src:a(4618),alt:"1624965654266"}})])])}),[],!1,null,null,null);n.default=e.exports}}]);