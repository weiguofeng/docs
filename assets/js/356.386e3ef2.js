(window.webpackJsonp=window.webpackJsonp||[]).push([[356],{5388:function(t,e,a){t.exports=a.p+"assets/img/image-20220410091639552.e2804b31.png"},5389:function(t,e,a){t.exports=a.p+"assets/img/image-20220410091722857.466f97f9.png"},5390:function(t,e,a){t.exports=a.p+"assets/img/image-20220410094700392.5e270107.png"},5391:function(t,e,a){t.exports=a.p+"assets/img/image-20220410095202316.ebccb94e.png"},5392:function(t,e,a){t.exports=a.p+"assets/img/image-20220410095349294.c260e32e.png"},5393:function(t,e,a){t.exports=a.p+"assets/img/image-20220410095459616.361e1627.png"},5394:function(t,e,a){t.exports=a.p+"assets/img/image-20220410095518484.fee1a33a.png"},5395:function(t,e,a){t.exports=a.p+"assets/img/image-20220410095805836.46d7dfa1.png"},8706:function(t,e,a){"use strict";a.r(e);var s=a(5),i=Object(s.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"_22-方法重写"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_22-方法重写"}},[t._v("#")]),t._v(" 22.方法重写")]),t._v(" "),s("p",[t._v("​\tOverride Method ：方法重写")]),t._v(" "),s("p",[t._v("​\t有些情况下，我们从父类继承了一个方法，但我们并不满意他的实现，我们想要改变他，这就是我们所说的方法重写，我们重写的是父类中声明的方法")]),t._v(" "),s("p",[t._v("​\t现在不要把方法重写和方法重载混淆了，方法重载是多次声明同一方法名称但参数不同。")]),t._v(" "),s("p",[t._v("​\t我们知道每个对象都有继承父类Object的toString方法，现在我们打印")]),t._v(" "),s("p",[s("img",{attrs:{src:a(5388),alt:"image-20220410091639552"}})]),t._v(" "),s("p",[t._v("​\t打印的值是 包+类名称+16进制的hashCode值")]),t._v(" "),s("p",[s("img",{attrs:{src:a(5389),alt:"image-20220410091722857"}})]),t._v(" "),s("p",[t._v("​\t\t我们对这样的输出不太满意，我们希望的是打印TextBox中的文本内容，所以我们需要重写这个方法，我们可以覆盖我们继承的任何方法")]),t._v(" "),s("p",[t._v("​\t重写方法需要在方法名称上加@Override，这就是我们所说的annotation注释，注释是一个基本调用，我们附加到类或者是成员上的标签，通过这个我们可以得到额外的信息到编译器，因此我们告诉java编译器我们正在重写Object类中的toString方法")]),t._v(" "),s("p",[s("img",{attrs:{src:a(5390),alt:"image-20220410094700392"}})]),t._v(" "),s("p",[t._v("​\t有了这个Java编译器将检查签名，对于该方法，他将确保该方法具有相同的精确签名也就是方法名称，现在我们有一个编译错误，因为在Object类中声明返回的是一个String，而我们现在是void，这就是使用这个注释的好处，它帮助java编译器的正确性，所以让我们改变这个返回值类型")]),t._v(" "),s("p",[s("img",{attrs:{src:a(5391),alt:"image-20220410095202316"}})]),t._v(" "),s("p",[s("img",{attrs:{src:a(5392),alt:"image-20220410095349294"}})]),t._v(" "),s("p",[t._v("​\t重写好了，现在我们回到main方法中，我们调用一下toString方法")]),t._v(" "),s("p",[s("img",{attrs:{src:a(5393),alt:"image-20220410095459616"}})]),t._v(" "),s("p",[t._v("​\t我们发现输出的内容是我们想要的内容")]),t._v(" "),s("p",[s("img",{attrs:{src:a(5394),alt:"image-20220410095518484"}})]),t._v(" "),s("p",[t._v("​\t\t这里我们没有显式的调用toString方法，如果是直接放入对象的话，因为println方法会调用自动调用任何对象上的toString方法")]),t._v(" "),s("p",[s("img",{attrs:{src:a(5395),alt:"image-20220410095805836"}})]),t._v(" "),s("p",[t._v("​")]),t._v(" "),s("p",[t._v("​\t以上就是方法重写的全部内容。")])])}),[],!1,null,null,null);e.default=i.exports}}]);