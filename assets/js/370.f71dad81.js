(window.webpackJsonp=window.webpackJsonp||[]).push([[370],{7552:function(t,s,r){t.exports=r.p+"assets/img/1643265125811.5b8fb83d.png"},7553:function(t,s,r){t.exports=r.p+"assets/img/1643269924303.e6b14b80.png"},7554:function(t,s,r){t.exports=r.p+"assets/img/1643270138300.f915d12c.png"},7555:function(t,s,r){t.exports=r.p+"assets/img/1643270546495.939f076a.png"},7556:function(t,s,r){t.exports=r.p+"assets/img/1643270659475.0f30880c.png"},7557:function(t,s,r){t.exports=r.p+"assets/img/1643271072520.bb1e6673.png"},7558:function(t,s,r){t.exports=r.p+"assets/img/1643271098327.87cf643b.png"},7559:function(t,s,r){t.exports=r.p+"assets/img/1643271272355.68af9402.png"},8942:function(t,s,r){"use strict";r.r(s);var e=r(5),a=Object(e.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"_5-容器化-docker的概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-容器化-docker的概念"}},[t._v("#")]),t._v(" 5.容器化-docker的概念")]),t._v(" "),e("p",[e("img",{attrs:{src:r(7552),alt:"1643265125811"}})]),t._v(" "),e("h4",{attrs:{id:"应用构建"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#应用构建"}},[t._v("#")]),t._v(" 应用构建：")]),t._v(" "),e("p",[t._v("​\t\t比如我们很多种语言开发的项目Java，C++，JavaScript等等，最终打了各种各样的包，每次对不同的包需要进行不同的部署方式比较繁琐。")]),t._v(" "),e("p",[t._v("​\t\t而像我们windows无论你是什么软件最终都给打成一个exe的包来执行安装。")]),t._v(" "),e("p",[t._v("​\t\tdocker的思路也是这样把所有的程序都使用docker build编译成为 docker镜像--所有的应用统一为docker镜像")]),t._v(" "),e("h4",{attrs:{id:"应用分享"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#应用分享"}},[t._v("#")]),t._v(" 应用分享：")]),t._v(" "),e("p",[t._v("​\t\t应用统一构建成 统一的标准后，可以把所有软件的镜像放到一个指定的地方 docker hub（相当于放到了应用市场）")]),t._v(" "),e("p",[t._v("​\t\t之后我们就可以访问这个docker hub 来下载我们需要的应用了---这样就解决了应用分享的问题")]),t._v(" "),e("h4",{attrs:{id:"应用的运行"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#应用的运行"}},[t._v("#")]),t._v(" 应用的运行")]),t._v(" "),e("p",[t._v("​\t因为有统一的标准"),e("strong",[t._v("镜像")]),t._v("，就像Windows的exe一样")]),t._v(" "),e("p",[t._v("​\t运行镜像就使用统一的命令 docker run 就可以了--（不像以前 需要单独启动java的，启动C++的，每次启动的模式也不一样，比较繁琐）")]),t._v(" "),e("p",[t._v("​\t我们在理解"),e("strong",[t._v("容器化")]),t._v("技术之前，先了解一下虚拟化技术，虚拟化技术解决了 强隔离的问题，但是每个虚拟机都需要独立的系统，这就导致创建稍微复杂，启动速度比较慢，还有就是虚拟系统占用空间比较多")]),t._v(" "),e("p",[e("img",{attrs:{src:r(7553),alt:"1643269924303"}})]),t._v(" "),e("p",[e("strong",[t._v("容器化技术：")])]),t._v(" "),e("p",[t._v("​\t   我们可以理解为docker是一个个的隔离沙箱环境，每个容器都是独立的，而且容器镜像是非常小的大约5M，相比于虚拟系统好几个G就轻量级很多了，而且启动速度快")]),t._v(" "),e("p",[t._v("​\t"),e("img",{attrs:{src:r(7554),alt:"1643270138300"}})]),t._v(" "),e("h4",{attrs:{id:"资源隔离-每个容器的隔离也是非常强可控的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#资源隔离-每个容器的隔离也是非常强可控的"}},[t._v("#")]),t._v(" 资源隔离--每个容器的隔离也是非常强可控的")]),t._v(" "),e("p",[e("img",{attrs:{src:r(7555),alt:"1643270546495"}})]),t._v(" "),e("p",[t._v("我们理解一下docker的架构--")]),t._v(" "),e("p",[t._v("​\t首先每一台机器都先安装docker，我们把安装了docker的机器叫做docker主机（DOCKER_HOST）")]),t._v(" "),e("p",[t._v("​\t安装了docker，系统就会启动一个docker进程 docker deamon")]),t._v(" "),e("p",[t._v("​\t一些docker的命令行操作 我们称为docker的客户端--然后给主机docker发送命令")]),t._v(" "),e("p",[t._v("​\tRegistry就是镜像的仓库，我们可以通过仓库来获取和推送镜像")]),t._v(" "),e("p",[t._v("​\tContainers是容器，将下载好的镜像放入容器中来启动")]),t._v(" "),e("p",[e("img",{attrs:{src:r(7556),alt:"1643270659475"}})]),t._v(" "),e("p",[t._v("​")]),t._v(" "),e("p",[t._v("比如下载redis的镜像")]),t._v(" "),e("p",[e("img",{attrs:{src:r(7557),alt:"1643271072520"}})]),t._v(" "),e("p",[t._v("然后docker pull redis就下载下来了 ---然后docker run 启动就搞定了")]),t._v(" "),e("p",[e("img",{attrs:{src:r(7558),alt:"1643271098327"}})]),t._v(" "),e("p",[e("img",{attrs:{src:r(7559),alt:"1643271272355"}})])])}),[],!1,null,null,null);s.default=a.exports}}]);