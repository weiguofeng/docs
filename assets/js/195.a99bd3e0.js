(window.webpackJsonp=window.webpackJsonp||[]).push([[195],{1377:function(t,s,a){t.exports=a.p+"assets/img/1655797924674.5e9a5e66.png"},1378:function(t,s,a){t.exports=a.p+"assets/img/1655798833373.86f5f1e0.png"},1379:function(t,s,a){t.exports=a.p+"assets/img/1655799444901.3faad251.png"},1380:function(t,s,a){t.exports=a.p+"assets/img/1655800166683.141c6083.png"},1381:function(t,s,a){t.exports=a.p+"assets/img/1655800329821.af396a01.png"},1382:function(t,s,a){t.exports=a.p+"assets/img/1655800661855.d11e513d.png"},1383:function(t,s,a){t.exports=a.p+"assets/img/1655800928772.55e2187f.png"},1384:function(t,s,a){t.exports=a.p+"assets/img/1655800975621.9842474a.png"},1385:function(t,s,a){t.exports=a.p+"assets/img/1655801289388.653a4bf0.png"},1386:function(t,s,a){t.exports=a.p+"assets/img/1655801425957.2b5fb73f.png"},1387:function(t,s,a){t.exports=a.p+"assets/img/1655803869051.f996b7fe.png"},1388:function(t,s,a){t.exports=a.p+"assets/img/1655803941744.d8ec82ec.png"},1389:function(t,s,a){t.exports=a.p+"assets/img/1655803998646.1b3aabdc.png"},1390:function(t,s,a){t.exports=a.p+"assets/img/1655804242237.c6e20b60.png"},8348:function(t,s,a){"use strict";a.r(s);var e=a(5),r=Object(e.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"_2-mobx基本使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-mobx基本使用"}},[t._v("#")]),t._v(" 2.mobx基本使用")]),t._v(" "),e("h4",{attrs:{id:"_1-环境配置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-环境配置"}},[t._v("#")]),t._v(" 1.环境配置")]),t._v(" "),e("p",[t._v("​\t\t首先我们使用Mobx得先去配置一下环境")]),t._v(" "),e("p",[t._v("​\t\t我们先初始化项目，然后安装mobx的2个核心包，mobx-react这个库是用来连接mobx和react的，因为默认 mobx和react其实是没有关系的，mobx也不一定要在react里使用，但是如果想在react中使用就需要安装mobx-react这个包")]),t._v(" "),e("p",[t._v("​\t\tmobx-react这个包支持函数组件也支持类组件，mobx-react-lite只支持函数组件--但体积小一些")]),t._v(" "),e("p",[e("img",{attrs:{src:a(1377),alt:"1655797924674"}})]),t._v(" "),e("p",[t._v("​\t添加依赖包")]),t._v(" "),e("p",[e("img",{attrs:{src:a(1378),alt:"1655798833373"}})]),t._v(" "),e("p",[t._v("​\t\t现在我们的环境就配置好了，也就是说我们初始化好了一个react项目并且安装了mobx的依赖包")]),t._v(" "),e("h4",{attrs:{id:"_2、核心概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、核心概念"}},[t._v("#")]),t._v(" 2、核心概念")]),t._v(" "),e("p",[t._v("​\t\t主要有三个核心概念，1.observable--被observable修饰后就变成一个可观察的，响应式的属性了，内部是通过ES6的Proxy实现的，将来的状态变更就会自动的追踪到这个状态变更")]),t._v(" "),e("p",[t._v("​\t\t\t\t2、action--是修饰一个函数，他主要是用来修改state状态的。")]),t._v(" "),e("p",[t._v("​\t\t\t\t3、computed--如果你有一些状态，想根据这些状态能够计算出新的值，那我们就需要用到计算属性，而且这个计算属性还可以把值缓存起来--多次使用只会计算一次")]),t._v(" "),e("p",[e("img",{attrs:{src:a(1379),alt:"1655799444901"}})]),t._v(" "),e("p",[t._v("​\t工作流程：首先触发某个事件，会掉一个Action，通过action去修改我们的状态，改完状态我们对应的计算属性会重新计算，最后会触发一些页面的副作用处理render")]),t._v(" "),e("h4",{attrs:{id:"_3、使用mobx"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、使用mobx"}},[t._v("#")]),t._v(" 3、使用mobx")]),t._v(" "),e("p",[t._v("​\t创建store，mobx里的store是一个class，因为类可以有属性也可以有方法")]),t._v(" "),e("p",[e("img",{attrs:{src:a(1380),alt:"1655800166683"}})]),t._v(" "),e("p",[t._v("​\t注意每个store只能初始化一次")]),t._v(" "),e("p",[e("img",{attrs:{src:a(1381),alt:"1655800329821"}})]),t._v(" "),e("p",[t._v("​\t因为每个store只能初始化一次，所以我们使用export  default new Counter这样我们就不是导出一个类，而是一个实例")]),t._v(" "),e("p",[t._v("​\t有个这个store之后，我们在页面中引入store")]),t._v(" "),e("p",[e("img",{attrs:{src:a(1382),alt:"1655800661855"}})]),t._v(" "),e("p",[t._v("​\t现在我们点击了页面的+1没有效果，因为现在我们的页面和组件还没有关联，所以我们就需要使用到另一个库里的方法mobx-react里面的observer是一个高阶组件函数，他需要包裹一个组件，这样这个组件就是响应式的，也就是说被包裹这个组件才可以正常的被更新")]),t._v(" "),e("p",[e("img",{attrs:{src:a(1383),alt:"1655800928772"}})]),t._v(" "),e("p",[t._v("​\t我们查看一下页面的效果：點擊+1有效果 了，点击重置也没有问题可以正常")]),t._v(" "),e("p",[e("img",{attrs:{src:a(1384),alt:"1655800975621"}})]),t._v(" "),e("p",[t._v("​\t这里有报一个警告就是，严格模式下面你是不允许直接修改这个数据的-如果没有在一个action里面")]),t._v(" "),e("p",[e("img",{attrs:{src:a(1385),alt:"1655801289388"}})]),t._v(" "),e("p",[t._v("​\t这是为什么呢，因为我们刚刚increment方法是action，而reset没有标记为action，所以要记得如果要修改状态值，方法一定要标记为action")]),t._v(" "),e("p",[e("img",{attrs:{src:a(1386),alt:"1655801425957"}})]),t._v(" "),e("p",[t._v("​\t\t其实到这里mobx就学会使用了")]),t._v(" "),e("h5",{attrs:{id:"this指向的问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#this指向的问题"}},[t._v("#")]),t._v(" this指向的问题")]),t._v(" "),e("p",[t._v("​\t因为我们现在Mobx是在class中使用的，默认class中的方法不会绑定this的，this指向取决于如何调用")]),t._v(" "),e("p",[t._v("​\t因为我们以上是通过counter.increment()，通过counter组件调用的方法this指向肯定没有问题")]),t._v(" "),e("p",[t._v("​\t如果我们去掉箭头函数--这个时候就会有问题")]),t._v(" "),e("p",[e("img",{attrs:{src:a(1387),alt:"1655803869051"}})]),t._v(" "),e("p",[t._v("​\t其实还是会指向这个counter组件中的increment方法，但是这个方法里的this就会有问题")]),t._v(" "),e("p",[e("img",{attrs:{src:a(1388),alt:"1655803941744"}})]),t._v(" "),e("p",[t._v("​\t我们测试一下--果然报错了")]),t._v(" "),e("p",[e("img",{attrs:{src:a(1389),alt:"1655803998646"}})]),t._v(" "),e("p",[t._v("那么为什么会这样呢？因为我们把counter.increment传给了Onclick，最终调的就是onclick，那这个时候这个counter类组件里面的this指向就会有问题，这个时候怎么办，我们可以在函数上添加bound，加了bound之后，这个函数里面的this指向就直接定死了，就指向当前的这个类")]),t._v(" "),e("p",[e("img",{attrs:{src:a(1390),alt:"1655804242237"}})])])}),[],!1,null,null,null);s.default=r.exports}}]);