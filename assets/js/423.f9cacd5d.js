(window.webpackJsonp=window.webpackJsonp||[]).push([[423],{5518:function(t,s,a){t.exports=a.p+"assets/img/image-20220412234538772.ff560b70.png"},5519:function(t,s,a){t.exports=a.p+"assets/img/image-20220412234925103.a71348b9.png"},5520:function(t,s,a){t.exports=a.p+"assets/img/image-20220412235156479.f0d46e1f.png"},5521:function(t,s,a){t.exports=a.p+"assets/img/image-20220413000120235.f2f6dca3.png"},5522:function(t,s,a){t.exports=a.p+"assets/img/image-20220413000908701.b9493540.png"},5523:function(t,s,a){t.exports=a.p+"assets/img/image-20220413001324713.c176bbac.png"},8744:function(t,s,a){"use strict";a.r(s);var e=a(5),p=Object(e.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"_34-构造器注入"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_34-构造器注入"}},[t._v("#")]),t._v(" 34.构造器注入")]),t._v(" "),e("p",[t._v("​\t我们不希望我们的报告类是依赖在实现上的，我们希望他依赖一个接口")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5518),alt:"image-20220412234538772"}})]),t._v(" "),e("p",[t._v("​")]),t._v(" "),e("p",[t._v("​\t所以我要用新的税务计算器 我们使用接口")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5519),alt:"image-20220412234925103"}})]),t._v(" "),e("p",[t._v("​\t我们也应该去掉下面的创建实例声明，我们不想让Report类知道关于这个具体是谁实现的，假如他不需要存在，所以我们需要添加一个参数，类型为税务计算器接口，这就是我们所说的构造函数注入")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5520),alt:"image-20220412235156479"}})]),t._v(" "),e("p",[t._v("​\t我们注入了一个依赖，使用构造函数的税务计算器接口，现在谁来注入这个呢？")]),t._v(" "),e("p",[t._v("​\t我们回到main方法，具体实施让我们通过我们的接口实现进行注入")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5521),alt:"image-20220413000120235"}})]),t._v(" "),e("p",[t._v("​\t我们的税务报告类对是由那个实现注入的一无所知，作为一个具体的实现，它只使用一个接口，这就是我们所说的针对接口编程，具体的注入实现是其他类的责任，比如我们的main类注入这些具体的实现，现在我们使用的是2018的税收计算器，明天我们可以创建另外一个类，比如2019的税收计算器，把这个传给我们的税务报告类也不受影响")]),t._v(" "),e("p",[t._v("​\t另外，如果我们回到这个具体的实现，例如我们改变了计算规则等等，我们的Report报告类是不受影响的，修改的类需要重新编译，但报告类不需要重新编译了，也不需要任何修改")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5522),alt:"image-20220413000908701"}})]),t._v(" "),e("p",[t._v("​\t这就是松耦合")]),t._v(" "),e("p",[t._v("​\t在这里我们注入的这种依赖，这就是我们所说的穷人的依赖注入")]),t._v(" "),e("p",[e("img",{attrs:{src:a(5523),alt:"image-20220413001324713"}})]),t._v(" "),e("p",[t._v("在这个程序中我们只有2个类，所以我们可以手动轻松创建和注入这些依赖项，在更大的应用程序中，我们可能有几百个类，这些类可能有几个依赖项，你不想在主方法中创建数百个对象并将他们传递给类的构造函数，这就是我们使用后期会使用依赖注入框架，因此有些框架可以实现这一点，很容易将这些依赖项传递给我们的类，Spring就是一个比较受欢迎的框架")]),t._v(" "),e("p",[t._v("​\t现在看看这些框架是如何工作的，以及我们如何使用他们，这超出了本课程的范围，我们未来研究这点")])])}),[],!1,null,null,null);s.default=p.exports}}]);