(window.webpackJsonp=window.webpackJsonp||[]).push([[607],{4807:function(t,a,s){t.exports=s.p+"assets/img/1624786130612.3d21f34f.png"},4808:function(t,a,s){t.exports=s.p+"assets/img/1624790369294.82a17e76.png"},8545:function(t,a,s){"use strict";s.r(a);var n=s(5),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"_08-啥-我发到消息队列里面的数据怎么不见了"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_08-啥-我发到消息队列里面的数据怎么不见了"}},[t._v("#")]),t._v(" 08_啥？我发到消息队列里面的数据怎么不见了？")]),t._v(" "),n("h4",{attrs:{id:"_1-面试题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-面试题"}},[t._v("#")]),t._v(" 1.面试题")]),t._v(" "),n("p",[n("strong",[t._v("如何保证消息的可靠性传输?(如何处理消息丢失的问题)")])]),t._v(" "),n("h4",{attrs:{id:"_2-面试官心里分析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-面试官心里分析"}},[t._v("#")]),t._v(" 2.面试官心里分析")]),t._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("\t这个是肯定的，用MQ有个基本原则，就是数据不能多一条，也不能少一条，不能多就是刚才说的重复消费和幂等性问题。不能少，就是说这数据别搞丢了，那这个问题你必须得考虑一下。\n\t\n\t如果说你这个是用mq来传递非常核心的消息，比如说计费，扣费的一些消息，因为我以前设计和研发过一个公司非常核心的广告平台，计费系统，计费系统是一个很重的业务，操作是很耗时的。所以说广告系统整体架构里面，实际上是将计费做成异步化的，然后中间就是加了一个MQ。\n\t\n\t我们当时为了确保说这个MQ的传递过程中绝对不会把计费消息给弄丢，花了很多精力。广告主投放一个广告，明明说好了，用户点击一次扣费1块钱，结果要是用户动不动点击了一次，扣费的时候搞的消息丢了，我们公司就会不断的少几块钱，几块钱，积少成多，这个就对公司是一个很大的损失。\n\t\n\t从生产者---RabbitMQ-----消费者，可能丢失数据的三种情况：\n\t\t1.写消息的过程中，消息都没到RabbitMQ在网络传输的过程中就丢了，或者消息到了RabbitMQ但是人家内部出错了，没保存下来也会导致数据丢失。\n\t\t2.RabbitMQ接收到消息之后先暂存在自己的内存里，结果消费者还没有消费，RabbitMQ自己挂掉了，就导致暂存在内存里的数据就给搞丢了。\n\t\t3.消费者消费到了这个消息，但还没来得及处理自己就挂掉了，但是RabbitMQ以为消费者已经处理完了。\n\t\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br"),n("span",{staticClass:"line-number"},[t._v("5")]),n("br"),n("span",{staticClass:"line-number"},[t._v("6")]),n("br"),n("span",{staticClass:"line-number"},[t._v("7")]),n("br"),n("span",{staticClass:"line-number"},[t._v("8")]),n("br"),n("span",{staticClass:"line-number"},[t._v("9")]),n("br"),n("span",{staticClass:"line-number"},[t._v("10")]),n("br"),n("span",{staticClass:"line-number"},[t._v("11")]),n("br")])]),n("h4",{attrs:{id:"_3-面试题剖析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-面试题剖析"}},[t._v("#")]),t._v(" 3.面试题剖析：")]),t._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("\t这个丢数据，mq一般分为俩种，要么是MQ自己弄丢了，要么是我们消费的时候弄丢了。\n\t\n\t咱们从RabbitMQ和kafka分别来分析一下吧。\n\t\n\tRabbitMQ这种MQ，一般来说都是承载公司核心业务的，数据是绝对不能弄丢的。\n\t\n\t\n\t1：RabbitMQ\n\t\t1.1生产者弄丢了数据：\n\t\t\t生产者将数据发送到RabbitMQ的时候，可能数据在半路就搞丢了，因为网络啥的问题，都有可能。\n\t\t\t此时可以选择用RabbitMQ提供的事务功能，就是生产者在发送数据之前开启RabbitMQ事务（channel.txSelect）,然后发送消息，如果消息没有成功被RabbitMQ接收到，那么生产者会收到异常报错，此时就会回滚事务（channel.txRollback）,然后重试发送消息。如果收到了消息，那么可以提交事务（channel.txCommit）.但是问题是，RabbitMQ的事务机制一搞，基本上吞吐量会下来，因为太耗性能了。而且这种情况是同步的就会导致生产者吞吐肯定下降，因为需要等待是否发送成功做出判断处理。\n\t\t\t\n\t\t\t所以一般来说，如果你要确保说些RabbitMQ的消息别丢，可以开启confirm模式，在生产者那里设置开启confirm模式之后，你每次写消息都会分配一个唯一的id，然后如果写入了RabbitMQ中，RabbitMQ会给你回传一个ack消息，告诉你这个消息ok了，如果RabbitMQ没能处理这个消息，会回调一个nack接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息id的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。\n\t\t\t\n\t\t\t事务机制和confirm机制最大的不同在于，事务机制是同步的，你提交事务之后会阻塞在那，但是confirm机制是异步的，你发送个消息之后就可以发送下一个消息，然后那个消息被RabbitMQ接收后会异步回调你一个接口通知你这个消息接收到了。\n\t\t\t所以一般生产者这块避免数据丢失，都是用confirm机制。\n\t\t\t\n\t\t1.2RabbitMQ弄丢了数据：\n\t\t\t就是RabbitMQ自己弄丢了数据，这个你必须开启RabbitMQ的持久化，就是写入消息之后会持久化到磁盘上，哪怕是RabbitMQ自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。除非极其罕见的是，RabbitMQ还没有持久化，自己就挂了，可能导致少量数据的丢失，但是这个概率较小。\n\t\t\t设置持久化有俩个步骤，\n\t\t\t\t第一个是创建queue的时候将其设置为持久化的，这样就可以保证RabbitMQ持久化queue的元数据，但是不会持久化queue里的数据。\n\t\t\t\t第二是发送消息的时候将消息的deliveryMode设置为2，就是将消息设置为持久化的，此时RabbitMQ就会将消息持久化到磁盘上去。\n\t\t\t\t必须同时设置这俩个持久化才可以，RabbitMQ哪怕是挂了，再次重启，也会从磁盘上重启恢复queue，恢复这个queue里面的数据。\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t而且持久化可以跟生产者那边的confirm机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者ack了，所以哪怕是在持久化到磁盘之前，RabbitMQ挂了，数据丢了，生产者收不到ack，你也是可以自己重发的。\n\t\t\t\t\n\t\t\t哪怕是你给rabbitmq开启了持久化机制，也有一种可能，就是这个消息写到了rabbitmq中，但是还没来得及持久化到磁盘上，结果不巧，此时rabbitmq挂了，就会导致内存里的一点点数据会丢失。\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t1.3 消费者弄丢了数据：\n\t\trabbitmq如果丢失了数据，主要是因为你消费的时候，刚消费到，还没处理，结果进程挂了，比如重启了，那么就尴尬了，rabbitmq认为你都消费了，这数据就丢了。\n\t\t\n\t\t这个时候得用rabbitmq提供的ack机制，简单来说，就是你关闭rabbitmq自动ack，可以通过一个api来调用就行，然后每次你自己代码里确保处理完的时候，再程序里ack一把。这样的话，如果你还没处理完，不就没有ack？那rabbitmq就认为你还没处理完，这个时候rabbitmq会把这个消费分配给别的consumer去处理，消息是不会丢的。\n\t\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br"),n("span",{staticClass:"line-number"},[t._v("5")]),n("br"),n("span",{staticClass:"line-number"},[t._v("6")]),n("br"),n("span",{staticClass:"line-number"},[t._v("7")]),n("br"),n("span",{staticClass:"line-number"},[t._v("8")]),n("br"),n("span",{staticClass:"line-number"},[t._v("9")]),n("br"),n("span",{staticClass:"line-number"},[t._v("10")]),n("br"),n("span",{staticClass:"line-number"},[t._v("11")]),n("br"),n("span",{staticClass:"line-number"},[t._v("12")]),n("br"),n("span",{staticClass:"line-number"},[t._v("13")]),n("br"),n("span",{staticClass:"line-number"},[t._v("14")]),n("br"),n("span",{staticClass:"line-number"},[t._v("15")]),n("br"),n("span",{staticClass:"line-number"},[t._v("16")]),n("br"),n("span",{staticClass:"line-number"},[t._v("17")]),n("br"),n("span",{staticClass:"line-number"},[t._v("18")]),n("br"),n("span",{staticClass:"line-number"},[t._v("19")]),n("br"),n("span",{staticClass:"line-number"},[t._v("20")]),n("br"),n("span",{staticClass:"line-number"},[t._v("21")]),n("br"),n("span",{staticClass:"line-number"},[t._v("22")]),n("br"),n("span",{staticClass:"line-number"},[t._v("23")]),n("br"),n("span",{staticClass:"line-number"},[t._v("24")]),n("br"),n("span",{staticClass:"line-number"},[t._v("25")]),n("br"),n("span",{staticClass:"line-number"},[t._v("26")]),n("br"),n("span",{staticClass:"line-number"},[t._v("27")]),n("br"),n("span",{staticClass:"line-number"},[t._v("28")]),n("br"),n("span",{staticClass:"line-number"},[t._v("29")]),n("br"),n("span",{staticClass:"line-number"},[t._v("30")]),n("br"),n("span",{staticClass:"line-number"},[t._v("31")]),n("br"),n("span",{staticClass:"line-number"},[t._v("32")]),n("br"),n("span",{staticClass:"line-number"},[t._v("33")]),n("br"),n("span",{staticClass:"line-number"},[t._v("34")]),n("br"),n("span",{staticClass:"line-number"},[t._v("35")]),n("br"),n("span",{staticClass:"line-number"},[t._v("36")]),n("br")])]),n("p",[n("strong",[t._v("RabbitMQ可能存在数据丢失的问题场景图：")])]),t._v(" "),n("p",[n("img",{attrs:{src:s(4807),alt:"1624786130612"}})]),t._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("\t2.kafka:\n\t\t2.1消费端弄丢了数据：\n\t\t\t唯一可能导致消费者弄丢数据的情况，就是说，你那个消费到了这个消息，然后消费者那边自动提交了offset，让kafka以为你已经消费好了这个消息，其实你刚准备处理这个消息，你还没处理，你自己就挂了，此时这条消息就丢咯。\n\n\t\t\t这不是一样么，大家都知道kafka会自动提交offset，那么只要关闭自动提交offset，在处理完之后自己手动提交offset，就可以保证数据不会丢。但是此时确实还是会重复消费，比如你刚处理完，还没提交offset，结果自己挂了，此时肯定会重复消费一次，自己保证幂等性就好了。\n\n\t\t\t生产环境碰到的一个问题，就是说我们的kafka消费者消费到了数据之后是写到一个内存的queue里先缓冲一下，结果有的时候，你刚把消息写入内存queue，然后消费者会自动提交offset。\n\n\t\t然后此时我们重启了系统，就会导致内存queue里还没来得及处理的数据就丢失了\n\t\t\n\t\t2.2kafka自己把数据搞丢了：\n\t\t\t这块比较常见的场景是，kafka某个broker宕机，然后重新选举partiton的leader时。大家想想此时，要是其他的follower刚好还有些数据没有同步，结果此时leader挂了，然后选举某个follower成为leader之后，他不就少了一些数据，这就丢了一些数据啊。\n\t\t\t\n\t\t\t生产环境也遇到过，我们也是，之前kafka的leader机器宕机了，将follower切换为leader之后，就会发现这个数据丢了。\n\t\t\t\n\t\t\t所以此时一般是要求起码设置如下4个参数：\n\t\t\t\t1.给这个topic设置replication.factor参数：这个值必须大于1，要求每个partition必须至少有2个副本。\n\t\t\t\t2.在kafka服务端设置min.insync.replicas参数：这个值必须大于1，这个是要求一个leader至少感知到有至少一个follower与自己保持联系，没掉队，这样才能确保leader挂了还有一个follower吧。\n\t\t\t\t\n\t\t\t\t3.在producer端设置acks=all：这个是要求每条数据，必须是写入所有replica副本之后，才能认为是写成功了。\n\t\t\t\t4.在producer端设置retries=MAX(一个很大很大的值，无限次重试的意思)：这个是要求一旦写入失败，就无限重试，卡在这里了。\n\t\t\t\t\n\t\t\t我们生产环境就是按照上述要求配置的，这样配置之后，至少在kafka broker端就可以保证在leader所在的broker发生故障，进行leader切换时，数据不会丢失。\n\t\t\t\n\t\t\n\t\t\n\t\t2.3生产者会不会弄丢数据\n\t\t\t如果按照上述的思路设置了ack=all，一定不会丢，要求是，你的leader接收到消息，所有的follower都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试，重试无限次。\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br"),n("span",{staticClass:"line-number"},[t._v("5")]),n("br"),n("span",{staticClass:"line-number"},[t._v("6")]),n("br"),n("span",{staticClass:"line-number"},[t._v("7")]),n("br"),n("span",{staticClass:"line-number"},[t._v("8")]),n("br"),n("span",{staticClass:"line-number"},[t._v("9")]),n("br"),n("span",{staticClass:"line-number"},[t._v("10")]),n("br"),n("span",{staticClass:"line-number"},[t._v("11")]),n("br"),n("span",{staticClass:"line-number"},[t._v("12")]),n("br"),n("span",{staticClass:"line-number"},[t._v("13")]),n("br"),n("span",{staticClass:"line-number"},[t._v("14")]),n("br"),n("span",{staticClass:"line-number"},[t._v("15")]),n("br"),n("span",{staticClass:"line-number"},[t._v("16")]),n("br"),n("span",{staticClass:"line-number"},[t._v("17")]),n("br"),n("span",{staticClass:"line-number"},[t._v("18")]),n("br"),n("span",{staticClass:"line-number"},[t._v("19")]),n("br"),n("span",{staticClass:"line-number"},[t._v("20")]),n("br"),n("span",{staticClass:"line-number"},[t._v("21")]),n("br"),n("span",{staticClass:"line-number"},[t._v("22")]),n("br"),n("span",{staticClass:"line-number"},[t._v("23")]),n("br"),n("span",{staticClass:"line-number"},[t._v("24")]),n("br"),n("span",{staticClass:"line-number"},[t._v("25")]),n("br"),n("span",{staticClass:"line-number"},[t._v("26")]),n("br"),n("span",{staticClass:"line-number"},[t._v("27")]),n("br"),n("span",{staticClass:"line-number"},[t._v("28")]),n("br")])]),n("p",[n("strong",[t._v("kafka数据丢失的图")])]),t._v(" "),n("p",[n("img",{attrs:{src:s(4808),alt:"1624790369294"}})])])}),[],!1,null,null,null);a.default=e.exports}}]);